<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Crossword Puzzle Generator</title>
  <style>
    /* ---------- Updated Color Palette for a more "Education.com-like" look ---------- */
    :root {
      --primary-color: #3BB8C7;      /* Softer teal */
      --secondary-color: #2D9AAA;    /* Deeper teal */
      --light-gray: #f5f5f5;        
      --dark-gray: #333;
      --border-color: #ddd;
    }
    * {
      box-sizing: border-box;
      /* Example of a clean, modern font similar to Education.com */
      font-family: 'Open Sans', sans-serif;
    }
    body {
      margin: 0;
      padding: 0;
      background-color: var(--light-gray); /* Softer background */
      color: var(--dark-gray);
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
      background-color: #fff; /* White container to stand out on the light gray body */
    }
    header {
      padding: 20px 0;
      border-bottom: 1px solid var(--border-color);
    }
    h1 {
      color: var(--primary-color);
      margin: 0;
      font-size: 2.2rem;
    }

    .content {
      display: flex;
      margin-top: 30px;
      gap: 40px;
    }
    .input-section {
      flex: 6;
    }
    .preview-section {
      flex: 5;
      background-color: #fff;
      padding: 20px;
      border-radius: 4px;
      position: relative;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Light shadow for a card-like look */
    }
    .section-title {
      font-size: 1.5rem;
      margin-bottom: 10px;
      color: var(--secondary-color);
    }
    .help-text {
      margin-bottom: 20px;
      color: #666;
      font-size: 14px;
    }
    .title-input {
      width: 100%;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      margin-bottom: 20px;
      font-size: 16px;
    }
    .word-input {
      width: 100%;
      height: 400px;
      padding: 15px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      resize: vertical;
      font-size: 15px;
      font-family: monospace;
      line-height: 1.5;
    }
    .create-btn {
      background-color: var(--secondary-color);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 10px 25px;
      cursor: pointer;
      font-size: 16px;
      margin-top: 20px;
      float: right;
    }
    .create-btn:hover {
      background-color: #238591; /* Slightly darker on hover */
    }
    .preview-tabs {
      display: flex;
      margin-bottom: 20px;
    }
    .preview-tab {
      padding: 8px 20px;
      cursor: pointer;
      background-color: #e0e0e0;
      border: none;
      margin-right: 5px;
      font-weight: bold;
      font-size: 14px;
      border-radius: 3px 3px 0 0;
      transition: background-color 0.2s;
    }
    .preview-tab:hover {
      background-color: #ccc;
    }
    .preview-tab.active {
      background-color: #fff;
    }
    .preview-content {
      background-color: white;
      border-radius: 4px;
      padding: 20px;
      text-align: center;
    }
    .preview-title {
      margin-bottom: 25px;
      font-size: 20px;
      font-weight: bold;
    }
    .download-section {
      margin-top: 20px;
    }
    .download-btn {
      background-color: var(--secondary-color);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 10px 15px;
      cursor: pointer;
      margin: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      text-align: center;
      font-size: 14px;
    }
    .download-btn:hover {
      background-color: #238591;
    }
    .download-btn svg {
      margin-right: 5px;
    }

    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: var(--primary-color);
      color: white;
      padding: 15px 20px;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      transform: translateX(200%);
      transition: transform 0.3s ease-in-out;
      z-index: 1000;
    }
    .notification.show {
      transform: translateX(0);
    }
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      display: none;
    }
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s ease-in-out infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* ---------- "Page preview" container, sized like A4 ---------- */
    .page-preview {
      width: 500px;
      height: 708px;
      border: 1px solid #ccc;
      margin: 0 auto;
      position: relative;
      overflow: hidden;
      box-shadow: 0 0 4px rgba(0,0,0,0.1);
      background-color: white;
    }
    /* Wrapper we can scale if puzzle is too large */
    .page-scale-wrapper {
      transform-origin: top left;
      position: absolute;
      left: 0;
      top: 0;
      width: auto;
      height: auto;
    }
    
    /* For PDF export - we'll hide this normally */
    .pdf-export-container {
      position: fixed;
      left: -9999px;
      top: -9999px;
      visibility: hidden;
    }
    .pdf-export-container.active {
      position: static;
      visibility: visible;
    }
    /* Make sure everything stays together in the PDF */
    .pdf-export-wrapper {
      page-break-inside: avoid !important;
      break-inside: avoid !important;
    }

    /* CROSSWORD LAYOUT */
    .crossword-grid-container {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }
    .crossword-grid {
      border-collapse: collapse;
      margin: 0 auto;
      margin-bottom: 20px;
      border: 2px solid white;
    }
    .crossword-grid td {
      padding: 0;
    }
    .crossword-cell {
      width: var(--cell-size, 20px);
      height: var(--cell-size, 20px);
      border: 1px solid #333;
      text-align: center;
      font-size: 14px;
      position: relative;
      background-color: white;
    }
    .cell-number {
      position: absolute;
      top: 1px;
      left: 2px;
      font-size: 9px;
      font-weight: normal;
    }
    .worksheet-heading {
      margin: 0 0 15px 0;
      text-align: left;
      font-weight: bold;
      font-size: 16px;
    }
    .clues-container {
  display: flex !important;
  flex-direction: row !important;
  flex-wrap: nowrap !important;
  justify-content: space-between;
  column-gap: 2rem; /* optional */
}
.across-clues, .down-clues {
  width: 45%;
  /* or flex: 1; if you prefer auto sizing */
}

    .clue-list {
      list-style-type: none;
      padding-left: 0;
    }
    .clue-item {
      margin-bottom: 8px;
      font-size: 14px;
      line-height: 1.4;
    }
    
    /* Footer with copyright or brand */
    .footer {
      text-align: center;
      margin-top: 40px;
      padding: 20px 0;
      font-size: 12px;
      color: #666;
      border-top: 1px solid var(--border-color);
    }

    /* ---------- PRINT & PDF STYLES ---------- */
    @media print {
      @page {
        size: A4;
        margin: 10mm; /* You can reduce to 5mm if you need more space */
      }
      body, html {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        font-size: 10pt;
      }
      .container, .input-section, .tabs, header,
      .create-btn, .preview-tabs, .download-section, .page-preview, .footer {
        display: none !important;
      }
      .preview-section {
        width: 100% !important;
        background: none;
        padding: 0;
        margin: 0;
        box-shadow: none;
      }
      .pdf-export-container {
        position: static !important;
        visibility: visible !important;
      }
      .pdf-export-container .crossword-grid-container {
        display: flex !important;
        justify-content: center !important;
        margin-bottom: 5mm !important;
      }
      .pdf-export-container .crossword-cell {
        width: 7mm; /* Shrink if you need everything to fit on one page */
        height: 7mm;
        border: 0.5pt solid black !important;
        font-size: 12pt;
      }
      .pdf-export-container .cell-number {
        font-size: 6pt;
      }

      /* Force side-by-side clues (flex row) in PDF: */
      .pdf-export-container .clues-container {
        display: flex !important;
        flex-direction: row !important;
        justify-content: space-between !important;
        column-gap: 2rem;
        /* Removing these helps keep on one page */
        flex-wrap: nowrap !important;
        margin-top: 5mm !important;
        page-break-before: avoid !important;
        page-break-inside: avoid !important;
      }
      .pdf-export-container .across-clues,
      .pdf-export-container .down-clues {
        width: 45%;
        page-break-inside: avoid !important;
      }
      
      .pdf-export-container .worksheet-heading {
        font-size: 12pt;
        margin-bottom: 4mm;
      }
      .pdf-export-container .preview-title {
        font-size: 16pt;
        margin-bottom: 8mm;
      }
      .clues-container {
    display: flex !important;
    flex-direction: row !important;
    flex-wrap: nowrap !important;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Crossword Puzzle Generator</h1>
    </header>
    <div class="content">
      <div class="input-section">
        <h3 class="section-title">Enter crossword puzzle content</h3>
        <p class="help-text">See instructions below. Under 20 words is best for a single page.</p>
        
        <div>
          <label for="puzzleTitle">Title</label>
          <input type="text" id="puzzleTitle" class="title-input" value="Crossword Puzzle">
        </div>
        
        <div>
          <label for="wordsList">Words</label>
          <textarea id="wordsList" class="word-input"
            placeholder="Type or paste your list of words here"></textarea>
        </div>
        
        <button class="create-btn" onclick="generateCrossword()">Create</button>
      </div>

      <div class="preview-section">
        <h3 class="section-title">Preview Worksheet</h3>
        <div class="preview-tabs">
          <button class="preview-tab active" onclick="showPreviewTab('worksheet')">WORKSHEET</button>
          <button class="preview-tab" onclick="showPreviewTab('answerKey')">ANSWER KEY</button>
        </div>
        
        <!-- The "page preview" that mimics A4 size -->
        <div class="page-preview">
          <!-- We'll scale the puzzle inside here if it's too large -->
          <div class="page-scale-wrapper" id="pageScaleWrapper">
            <div id="previewContent" class="preview-content">
              <div id="worksheetPreview">
                <h3 class="preview-title" id="previewTitle">Crossword Puzzle</h3>
                <div id="crosswordContainer">
                  <p>Your puzzle will appear here after you create it.</p>
                </div>
              </div>
              <div id="answerKeyPreview" style="display: none;">
                <h3 class="preview-title" id="answerKeyTitle">Crossword Puzzle</h3>
                <div id="answerKeyContainer">
                  <p>Your answer key will appear here after you create it.</p>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="download-section">
          <button class="download-btn" onclick="printPuzzle()">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
              <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
              <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
            </svg>
            Download Worksheet
          </button>
          
          <button class="download-btn" onclick="printAnswerKey()">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
              <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
              <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
            </svg>
            Download Answer Key
          </button>
        </div>
      </div>
    </div>
    
    <!-- Footer with brand/copyright -->
    <div class="footer">
      made with ❤️ by Shandé
    </div>
  </div>

  <!-- Hidden containers for PDF export (no scaling applied) -->
  <div id="pdfWorksheetContainer" class="pdf-export-container"></div>
  <div id="pdfAnswerKeyContainer" class="pdf-export-container"></div>

  <div class="notification" id="notification">Notification message</div>
  <div class="loading-overlay" id="loadingOverlay">
    <div class="spinner"></div>
  </div>

  <!-- html2pdf -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script>
    // Global variables
    let generatedPuzzle = null;
    let currentPreviewTab = 'worksheet';
    
    // Example placeholder
    window.onload = function() {
      const wordsList = document.getElementById('wordsList');
      if (!wordsList.value) {
        wordsList.placeholder = 
`fire, flames that burn and can cause damage
fire fighter, a person whose job is to put out fires
smoke, the gray or black cloud that comes from a fire
burn, an injury caused by fire or heat
to save, to stop something from being damaged or destroyed
to rescue, to save someone from danger
to survive, to continue to live after a dangerous situation`;
      }
    };

    function showPreviewTab(tabName) {
      currentPreviewTab = tabName;
      const previewTabs = document.getElementsByClassName("preview-tab");
      for (let i = 0; i < previewTabs.length; i++) {
        previewTabs[i].classList.remove("active");
      }
      document.querySelector(`.preview-tab[onclick="showPreviewTab('${tabName}')"]`)
              .classList.add("active");

      // Show/hide the correct preview
      if (tabName === 'worksheet') {
        document.getElementById('worksheetPreview').style.display = 'block';
        document.getElementById('answerKeyPreview').style.display = 'none';
      } else {
        document.getElementById('worksheetPreview').style.display = 'none';
        document.getElementById('answerKeyPreview').style.display = 'block';
      }
      updatePreviewScale();
    }
    
    function showNotification(message) {
      const notification = document.getElementById("notification");
      notification.textContent = message;
      notification.classList.add("show");
      setTimeout(() => {
        notification.classList.remove("show");
      }, 3000);
    }
    
    function showLoading(show) {
      document.getElementById("loadingOverlay").style.display = show ? "flex" : "none";
    }
    
    // Scale the puzzle to fit within .page-preview
    function updatePreviewScale() {
      const previewWrapper = document.querySelector('.page-preview');
      const scaleWrapper = document.getElementById('pageScaleWrapper');
      // reset scale so we measure "actual" size
      scaleWrapper.style.transform = 'scale(1)';

      const maxW = previewWrapper.clientWidth;
      const maxH = previewWrapper.clientHeight;
      const contentW = scaleWrapper.scrollWidth;
      const contentH = scaleWrapper.scrollHeight;

      let scale = 1;
      if (contentW && contentH) {
        const scaleW = maxW / contentW;
        const scaleH = maxH / contentH;
        scale = Math.min(scaleW, scaleH, 1);
      }
      scaleWrapper.style.transform = `scale(${scale})`;
    }

    // Parse user input
    function parseWordsInput() {
      const wordsText = document.getElementById('wordsList').value.trim();
      const lines = wordsText.split('\n');
      const words = [];
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;

        const firstCommaIndex = line.indexOf(',');
        if (firstCommaIndex === -1) {
          showNotification("Line " + (i + 1) + " is missing a definition. Format: term, definition");
          return null;
        }

        const term = line.substring(0, firstCommaIndex).trim().toUpperCase();
        const definition = line.substring(firstCommaIndex + 1).trim();
        const cleanTerm = term.replace(/[^A-Z]/g, "");
        if (cleanTerm.length < 2) {
          showNotification("Term '" + term + "' is too short (2+ letters).");
          return null;
        }
        words.push({ word: cleanTerm, clue: definition });
      }
      if (words.length < 3) {
        showNotification("Please enter at least 3 terms with definitions");
        return null;
      }
      if (words.length > 20) {
        showNotification("Too many terms. Please limit to 20 for best layout.");
        return null;
      }
      return words;
    }

    // Generate puzzle
    function generateCrossword() {
      showLoading(true);
      setTimeout(() => {
        try {
          const words = parseWordsInput();
          if (!words) {
            showLoading(false);
            return;
          }
          const puzzleTitle = document.getElementById('puzzleTitle').value || "Crossword Puzzle";
          document.getElementById('previewTitle').textContent = puzzleTitle;
          document.getElementById('answerKeyTitle').textContent = puzzleTitle;

          try {
            generatedPuzzle = createCrosswordGrid(words);
            renderCrossword(generatedPuzzle, false); // Worksheet
            renderCrossword(generatedPuzzle, true);  // Answer Key
            showPreviewTab('worksheet');
          } catch (err) {
            console.error(err);
            showNotification("Error generating crossword. Try different terms.");
          }
        } catch (err) {
          console.error(err);
          showNotification("Error processing input. Check format.");
        } finally {
          showLoading(false);
        }
      }, 100);
    }

    // The improved crossword algorithm
    function createCrosswordGrid(words) {
      // Sort words by length descending
      words.sort((a, b) => b.word.length - a.word.length);
      
      // Try multiple layouts
      const attempts = 8; 
      let bestLayout = null;
      let bestScore = -Infinity;
      
      for (let attempt = 0; attempt < attempts; attempt++) {
        try {
          const layout = generateLayout(words, attempt);
          if (!layout) continue;
          
          const score = scoreLayout(layout);
          if (score > bestScore) {
            bestScore = score;
            bestLayout = layout;
          }
        } catch (e) {
          console.log("Layout attempt failed:", e);
        }
      }
      
      // If we found a good layout
      if (bestLayout && bestLayout.placedWords.length >= Math.min(words.length * 0.8, words.length)) {
        return bestLayout;
      }
      
      // Fallback to original
      return generateOriginalLayout(words);
    }
    
    function scoreLayout(layout) {
      let acrossCount = 0;
      let downCount = 0;
      layout.placedWords.forEach(word => {
        if (word.horizontal) acrossCount++;
        else downCount++;
      });
      const height = layout.grid.length;
      const width = layout.grid[0].length;
      const aspectRatio = width / height;
      const squareness = Math.min(aspectRatio, 1 / aspectRatio);
      const directionBalance = Math.min(acrossCount, downCount) / Math.max(acrossCount, downCount);
      const wordPlacementRatio = layout.placedWords.length / layout.totalWords;
      let intersections = 0;
      for (let i = 0; i < layout.placedWords.length; i++) {
        for (let j = i + 1; j < layout.placedWords.length; j++) {
          if (wordsIntersect(layout.placedWords[i], layout.placedWords[j])) {
            intersections++;
          }
        }
      }
      const intersectionDensity = intersections / Math.max(1, layout.placedWords.length);
      
      return (wordPlacementRatio * 40) + (squareness * 30) + (directionBalance * 20) + (intersectionDensity * 10);
    }
    
    function wordsIntersect(word1, word2) {
      if (word1.horizontal === word2.horizontal) return false;
      const horizontal = word1.horizontal ? word1 : word2;
      const vertical = word1.horizontal ? word2 : word1;
      
      return horizontal.startX <= vertical.startX && 
             horizontal.startX + horizontal.word.length > vertical.startX &&
             vertical.startY <= horizontal.startY &&
             vertical.startY + vertical.word.length > horizontal.startY;
    }
    
    function generateLayout(words, attemptNumber) {
      const gridSize = calculateGridSize(words);
      const grid = createEmptyGrid(gridSize);
      const placedWords = [];
      
      let acrossCount = 0;
      let downCount = 0;
      const firstWordHorizontal = attemptNumber % 2 === 0;
      const firstWord = words[0];
      const startX = Math.floor((gridSize - firstWord.word.length) / 2);
      const startY = Math.floor(gridSize / 2);
      placeWordOnGrid(grid, firstWord.word, startX, startY, firstWordHorizontal);
      placedWords.push({
        word: firstWord.word,
        clue: firstWord.clue,
        startX: startX,
        startY: startY,
        horizontal: firstWordHorizontal
      });
      if (firstWordHorizontal) acrossCount++; else downCount++;
      
      const remainingWords = [...words.slice(1)];
      if (attemptNumber > 0) {
        for (let i = 0; i < attemptNumber; i++) {
          remainingWords.sort(() => Math.random() - 0.5);
        }
      }
      
      for (let i = 0; i < remainingWords.length; i++) {
        const currentWord = remainingWords[i];
        let placementFound = false;
        const preferHorizontal = acrossCount <= downCount;
        const orientations = preferHorizontal 
          ? [{ horizontal: true }, { horizontal: false }] 
          : [{ horizontal: false }, { horizontal: true }];
        
        const possiblePlacements = findPossiblePlacements(grid, currentWord, placedWords, preferHorizontal);
        
        if (possiblePlacements.length > 0) {
          possiblePlacements.sort((a, b) => b.score - a.score);
          const bestPlacement = possiblePlacements[0];
          placeWordOnGrid(grid, currentWord.word, bestPlacement.x, bestPlacement.y, bestPlacement.horizontal);
          placedWords.push({
            word: currentWord.word,
            clue: currentWord.clue,
            startX: bestPlacement.x,
            startY: bestPlacement.y,
            horizontal: bestPlacement.horizontal
          });
          if (bestPlacement.horizontal) acrossCount++; else downCount++;
          placementFound = true;
        }
      }
      
      const trimmed = trimGrid(grid);
      const adjustX = trimmed.trimFromLeft;
      const adjustY = trimmed.trimFromTop;
      for (let i = 0; i < placedWords.length; i++) {
        placedWords[i].startX -= adjustX;
        placedWords[i].startY -= adjustY;
      }
      
      numberGrid(trimmed.grid, placedWords);
      const acrossClues = [];
      const downClues = [];
      for (let w of placedWords) {
        if (w.horizontal) {
          acrossClues.push({ number: w.number, clue: w.clue, word: w.word });
        } else {
          downClues.push({ number: w.number, clue: w.clue, word: w.word });
        }
      }
      acrossClues.sort((a, b) => a.number - b.number);
      downClues.sort((a, b) => a.number - b.number);
      
      return {
        grid: trimmed.grid,
        placedWords: placedWords,
        acrossClues,
        downClues,
        totalWords: words.length
      };
    }

    function findPossiblePlacements(grid, currentWord, placedWords, preferHorizontal) {
      const possiblePlacements = [];
      const orientations = preferHorizontal 
        ? [{ horizontal: true }, { horizontal: false }] 
        : [{ horizontal: false }, { horizontal: true }];

      for (const orientation of orientations) {
        for (const placedWord of placedWords) {
          for (let i = 0; i < currentWord.word.length; i++) {
            for (let j = 0; j < placedWord.word.length; j++) {
              if (currentWord.word[i] === placedWord.word[j]) {
                let x, y;
                if (orientation.horizontal) {
                  x = placedWord.startX + (placedWord.horizontal ? j : 0) - i;
                  y = placedWord.startY + (placedWord.horizontal ? 0 : j);
                } else {
                  x = placedWord.startX + (placedWord.horizontal ? j : 0);
                  y = placedWord.startY + (placedWord.horizontal ? 0 : j) - i;
                }
                
                if (canPlaceWord(grid, currentWord.word, x, y, orientation.horizontal)) {
                  const potentialScore = calculatePlacementScore(grid, currentWord.word, x, y, orientation.horizontal, placedWords);
                  possiblePlacements.push({
                    x,
                    y,
                    horizontal: orientation.horizontal,
                    score: potentialScore
                  });
                }
              }
            }
          }
        }
      }
      
      return possiblePlacements;
    }
    
    function calculatePlacementScore(grid, word, startX, startY, horizontal, placedWords) {
      let score = 0;
      for (let i = 0; i < word.length; i++) {
        const x = horizontal ? startX + i : startX;
        const y = horizontal ? startY : startY + i;
        if (grid[y] && grid[y][x] === word[i]) {
          score += 5; // intersection bonus
        }
      }
      const currentMaxX = Math.max(...placedWords.map(w => w.horizontal ? w.startX + w.word.length - 1 : w.startX));
      const currentMaxY = Math.max(...placedWords.map(w => w.horizontal ? w.startY : w.startY + w.word.length - 1));
      const currentMinX = Math.min(...placedWords.map(w => w.startX));
      const currentMinY = Math.min(...placedWords.map(w => w.startY));
      
      const newMaxX = horizontal ? startX + word.length - 1 : startX;
      const newMaxY = horizontal ? startY : startY + word.length - 1;
      
      const expansion = Math.max(0, newMaxX - currentMaxX)
                      + Math.max(0, newMaxY - currentMaxY)
                      + Math.max(0, currentMinX - startX)
                      + Math.max(0, currentMinY - startY);
      score -= expansion;
      
      const currentWidth = currentMaxX - currentMinX + 1;
      const currentHeight = currentMaxY - currentMinY + 1;
      const currentRatio = currentWidth / currentHeight;

      const newWidth = Math.max(currentMaxX, newMaxX) - Math.min(currentMinX, startX) + 1;
      const newHeight = Math.max(currentMaxY, newMaxY) - Math.min(currentMinY, startY) + 1;
      const newRatio = newWidth / newHeight;
      if (Math.abs(newRatio - 1) < Math.abs(currentRatio - 1)) {
        score += 3; 
      }
      return score;
    }
    
    function generateOriginalLayout(words) {
      const gridSize = calculateGridSize(words);
      const grid = createEmptyGrid(gridSize);
      const placedWords = [];
      const firstWord = words[0];
      const startX = Math.floor((gridSize - firstWord.word.length) / 2);
      const startY = Math.floor(gridSize / 2);
      placeWordOnGrid(grid, firstWord.word, startX, startY, true);
      placedWords.push({
        word: firstWord.word,
        clue: firstWord.clue,
        startX: startX,
        startY: startY,
        horizontal: true
      });

      for (let i = 1; i < words.length; i++) {
        const currentWord = words[i];
        let placed = false;
        for (let j = 0; j < placedWords.length && !placed; j++) {
          const placedWord = placedWords[j];
          if (!placedWord.horizontal) {
            for (let charIndex = 0; charIndex < currentWord.word.length && !placed; charIndex++) {
              for (let pc = 0; pc < placedWord.word.length && !placed; pc++) {
                if (currentWord.word[charIndex] === placedWord.word[pc]) {
                  const newX = placedWord.startX - charIndex;
                  const newY = placedWord.startY + pc;
                  if (canPlaceWord(grid, currentWord.word, newX, newY, true)) {
                    placeWordOnGrid(grid, currentWord.word, newX, newY, true);
                    placedWords.push({
                      word: currentWord.word,
                      clue: currentWord.clue,
                      startX: newX,
                      startY: newY,
                      horizontal: true
                    });
                    placed = true;
                  }
                }
              }
            }
          }
          if (placedWord.horizontal && !placed) {
            for (let charIndex = 0; charIndex < currentWord.word.length && !placed; charIndex++) {
              for (let pc = 0; pc < placedWord.word.length && !placed; pc++) {
                if (currentWord.word[charIndex] === placedWord.word[pc]) {
                  const newX = placedWord.startX + pc;
                  const newY = placedWord.startY - charIndex;
                  if (canPlaceWord(grid, currentWord.word, newX, newY, false)) {
                    placeWordOnGrid(grid, currentWord.word, newX, newY, false);
                    placedWords.push({
                      word: currentWord.word,
                      clue: currentWord.clue,
                      startX: newX,
                      startY: newY,
                      horizontal: false
                    });
                    placed = true;
                  }
                }
              }
            }
          }
        }
      }
      
      const trimmed = trimGrid(grid);
      const adjustX = trimmed.trimFromLeft;
      const adjustY = trimmed.trimFromTop;
      for (let i = 0; i < placedWords.length; i++) {
        placedWords[i].startX -= adjustX;
        placedWords[i].startY -= adjustY;
      }
      numberGrid(trimmed.grid, placedWords);
      const acrossClues = [];
      const downClues = [];
      for (let w of placedWords) {
        if (w.horizontal) {
          acrossClues.push({ number: w.number, clue: w.clue, word: w.word });
        } else {
          downClues.push({ number: w.number, clue: w.clue, word: w.word });
        }
      }
      acrossClues.sort((a, b) => a.number - b.number);
      downClues.sort((a, b) => a.number - b.number);
      
      return {
        grid: trimmed.grid,
        placedWords,
        acrossClues,
        downClues,
        totalWords: words.length
      };
    }

    function calculateGridSize(words) {
      let maxLength = 0;
      for (let w of words) {
        maxLength = Math.max(maxLength, w.word.length);
      }
      return Math.max(20, maxLength + 10);
    }

    function createEmptyGrid(size) {
      const g = [];
      for (let y = 0; y < size; y++) {
        g[y] = [];
        for (let x = 0; x < size; x++) {
          g[y][x] = null;
        }
      }
      return g;
    }

    function canPlaceWord(grid, word, startX, startY, horizontal) {
      const gridSize = grid.length;
      if (horizontal) {
        if (startX < 0 || startX + word.length > gridSize || startY < 0 || startY >= gridSize) {
          return false;
        }
      } else {
        if (startX < 0 || startX >= gridSize || startY < 0 || startY + word.length > gridSize) {
          return false;
        }
      }
      let hasIntersection = false;
      for (let i = 0; i < word.length; i++) {
        const x = horizontal ? startX + i : startX;
        const y = horizontal ? startY : startY + i;
        if (grid[y][x] !== null && grid[y][x] !== word[i]) {
          return false;
        }
        if (grid[y][x] === word[i]) {
          hasIntersection = true;
        } else {
          if (horizontal) {
            if (y > 0 && grid[y-1][x] !== null) return false;
            if (y < gridSize - 1 && grid[y+1][x] !== null) return false;
            if (i === 0 && x > 0 && grid[y][x-1] !== null) return false;
            if (i === word.length - 1 && x < gridSize - 1 && grid[y][x+1] !== null) return false;
          } else {
            if (x > 0 && grid[y][x-1] !== null) return false;
            if (x < gridSize - 1 && grid[y][x+1] !== null) return false;
            if (i === 0 && y > 0 && grid[y-1][x] !== null) return false;
            if (i === word.length - 1 && y < gridSize - 1 && grid[y+1][x] !== null) return false;
          }
        }
      }
      return hasIntersection 
             || (startX === Math.floor((gridSize - word.length) / 2)
                 && startY === Math.floor(gridSize / 2));
    }

    function placeWordOnGrid(grid, word, startX, startY, horizontal) {
      for (let i = 0; i < word.length; i++) {
        if (horizontal) {
          grid[startY][startX + i] = word[i];
        } else {
          grid[startY + i][startX] = word[i];
        }
      }
    }

    function trimGrid(grid) {
      const size = grid.length;
      let minX = size, maxX = 0, minY = size, maxY = 0;
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (grid[y][x] !== null) {
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
          }
        }
      }
      minX = Math.max(0, minX - 1);
      minY = Math.max(0, minY - 1);
      maxX = Math.min(size - 1, maxX + 1);
      maxY = Math.min(size - 1, maxY + 1);
      const newWidth = maxX - minX + 1;
      const newHeight = maxY - minY + 1;
      const trimmedGrid = [];
      for (let y = 0; y < newHeight; y++) {
        trimmedGrid[y] = [];
        for (let x = 0; x < newWidth; x++) {
          trimmedGrid[y][x] = grid[y + minY][x + minX];
        }
      }
      return {
        grid: trimmedGrid,
        trimFromLeft: minX,
        trimFromTop: minY
      };
    }

    function numberGrid(grid, placedWords) {
      const height = grid.length;
      const width = grid[0].length;
      let currentNumber = 1;
      for (let pw of placedWords) {
        delete pw.number;
      }
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          if (grid[y][x] !== null) {
            let numberH = false;
            let numberV = false;
            if ((x === 0 || grid[y][x-1] === null)
                && (x < width - 1 && grid[y][x+1] !== null)) {
              numberH = true;
            }
            if ((y === 0 || grid[y-1][x] === null)
                && (y < height - 1 && grid[y+1][x] !== null)) {
              numberV = true;
            }
            if (numberH || numberV) {
              if (numberH) {
                for (let pw of placedWords) {
                  if (pw.horizontal && pw.startX === x && pw.startY === y) {
                    pw.number = currentNumber;
                  }
                }
              }
              if (numberV) {
                for (let pw of placedWords) {
                  if (!pw.horizontal && pw.startX === x && pw.startY === y) {
                    pw.number = currentNumber;
                  }
                }
              }
              currentNumber++;
            }
          }
        }
      }
      for (let pw of placedWords) {
        if (pw.number === undefined) {
          pw.number = currentNumber++;
        }
      }
    }

    function renderCrossword(puzzle, showAnswers) {
      const grid = puzzle.grid;
      const height = grid.length;
      const width = grid[0].length;
      
      // Adjust cell size based on puzzle dimension
      const maxDim = Math.max(width, height);
      let cellSize = '25px';
      if (maxDim > 15) { cellSize = '22px'; }
      else if (maxDim > 12) { cellSize = '24px'; }

      let html = `<div class="crossword-grid-container">
                    <table class="crossword-grid" style="--cell-size: ${cellSize};">`;
      for (let y = 0; y < height; y++) {
        html += '<tr>';
        for (let x = 0; x < width; x++) {
          if (grid[y][x] === null) {
            html += '<td></td>';
          } else {
            let cellNumber = '';
            if (isStartOfWord(grid, x, y)) {
              const n = getWordNumber(puzzle.placedWords, x, y);
              if (n) {
                cellNumber = `<span class="cell-number">${n}</span>`;
              }
            }
            const cellContent = showAnswers ? grid[y][x] : '';
            html += `<td class="crossword-cell">${cellNumber}${cellContent}</td>`;
          }
        }
        html += '</tr>';
      }
      html += '</table></div>';
      
      // Clues
      html += '<div class="clues-container">';
      if (puzzle.acrossClues.length > 0) {
        html += '<div class="across-clues">';
        html += '<div class="worksheet-heading">Across:</div>';
        html += '<ol class="clue-list">';
        for (let clue of puzzle.acrossClues) {
          html += `<li class="clue-item"><strong>${clue.number}.</strong> ${clue.clue}</li>`;
        }
        html += '</ol></div>';
      }
      if (puzzle.downClues.length > 0) {
        html += '<div class="down-clues">';
        html += '<div class="worksheet-heading">Down:</div>';
        html += '<ol class="clue-list">';
        for (let clue of puzzle.downClues) {
          html += `<li class="clue-item"><strong>${clue.number}.</strong> ${clue.clue}</li>`;
        }
        html += '</ol></div>';
      }
      html += '</div>';

      if (showAnswers) {
        document.getElementById('answerKeyContainer').innerHTML = html;
        document.getElementById('pdfAnswerKeyContainer').innerHTML = 
          `<div class="preview-content">
            <div class="pdf-export-wrapper">
              <h3 class="preview-title">${document.getElementById('puzzleTitle').value || "Crossword Puzzle"}</h3>
              ${html}
            </div>
          </div>`;
      } else {
        document.getElementById('crosswordContainer').innerHTML = html;
        document.getElementById('pdfWorksheetContainer').innerHTML = 
          `<div class="preview-content">
            <div class="pdf-export-wrapper">
              <h3 class="preview-title">${document.getElementById('puzzleTitle').value || "Crossword Puzzle"}</h3>
              ${html}
            </div>
          </div>`;
      }
      
      updatePreviewScale();
    }

    function isStartOfWord(grid, x, y) {
      if (grid[y][x] === null) return false;
      const height = grid.length;
      const width = grid[0].length;
      const horizStart = ((x === 0 || grid[y][x-1] === null)
                          && (x < width - 1 && grid[y][x+1] !== null));
      const vertStart = ((y === 0 || grid[y-1][x] === null)
                          && (y < height - 1 && grid[y+1][x] !== null));
      return horizStart || vertStart;
    }

    function getWordNumber(placedWords, x, y) {
      for (let pw of placedWords) {
        if (pw.startX === x && pw.startY === y) {
          return pw.number;
        }
      }
      return null;
    }

    // PDF export
    function printPuzzle() {
      if (!generatedPuzzle) {
        showNotification("Generate a puzzle first");
        return;
      }
      
      const puzzleTitle = (document.getElementById('puzzleTitle').value || "Crossword_Puzzle")
                          .replace(/\s+/g, '_');
      const filename = puzzleTitle + '.pdf';
      
      const content = document.getElementById('pdfWorksheetContainer');
      content.classList.add('active'); // Make it visible for html2pdf
      
      // Make sure all is visible
      const cluesContainer = content.querySelector('.clues-container');
      if (cluesContainer) {
        cluesContainer.style.display = 'flex';
        cluesContainer.style.visibility = 'visible';
        cluesContainer.style.height = 'auto';
      }
      
      const options = {
        margin: [10, 10, 10, 10],
        filename: filename,
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: {
          scale: 2,
          useCORS: true,
          scrollY: 0,
          windowHeight: 2000,
          onclone: function(doc) {
            const cluesContainer = doc.querySelector('.pdf-export-container .clues-container');
            if (cluesContainer) {
              cluesContainer.style.display = 'flex';
              cluesContainer.style.visibility = 'visible';
              cluesContainer.style.position = 'static';
              cluesContainer.style.overflow = 'visible';
              cluesContainer.style.height = 'auto';
            }
          }
        },
        jsPDF: {
          unit: 'mm',
          format: 'a4',
          orientation: 'portrait',
          compress: true
        },
        pagebreak: { mode: ['avoid', 'css', 'legacy'], avoid: '.pdf-export-wrapper' }
      };
      
      showLoading(true);
      
      setTimeout(() => {
        html2pdf()
          .set(options)
          .from(content)
          .save()
          .then(() => {
            content.classList.remove('active');
            showLoading(false);
            showNotification("Worksheet downloaded successfully");
          })
          .catch(err => {
            content.classList.remove('active');
            showLoading(false);
            console.error("PDF generation error:", err);
            showNotification("Error downloading PDF. Try again.");
          });
      }, 100);
    }

    function printAnswerKey() {
      if (!generatedPuzzle) {
        showNotification("Generate a puzzle first");
        return;
      }
      
      const puzzleTitle = (document.getElementById('puzzleTitle').value || "Crossword_Puzzle")
                          .replace(/\s+/g, '_');
      const filename = puzzleTitle + '_Answer_Key.pdf';
      
      const content = document.getElementById('pdfAnswerKeyContainer');
      content.classList.add('active');
      
      const cluesContainer = content.querySelector('.clues-container');
      if (cluesContainer) {
        cluesContainer.style.display = 'flex';
        cluesContainer.style.visibility = 'visible';
        cluesContainer.style.height = 'auto';
      }
      
      const options = {
        margin: [10, 10, 10, 10],
        filename: filename,
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: {
          scale: 2,
          useCORS: true,
          scrollY: 0,
          windowHeight: 2000,
          onclone: function(doc) {
            const cluesContainer = doc.querySelector('.pdf-export-container .clues-container');
            if (cluesContainer) {
              cluesContainer.style.display = 'flex';
              cluesContainer.style.visibility = 'visible';
              cluesContainer.style.position = 'static';
              cluesContainer.style.overflow = 'visible';
              cluesContainer.style.height = 'auto';
            }
          }
        },
        jsPDF: {
          unit: 'mm',
          format: 'a4',
          orientation: 'portrait',
          compress: true
        },
        pagebreak: { mode: ['avoid', 'css', 'legacy'], avoid: '.pdf-export-wrapper' }
      };
      
      showLoading(true);
      
      setTimeout(() => {
        html2pdf()
          .set(options)
          .from(content)
          .save()
          .then(() => {
            content.classList.remove('active');
            showLoading(false);
            showNotification("Answer key downloaded successfully");
          })
          .catch(err => {
            content.classList.remove('active');
            showLoading(false);
            console.error("PDF generation error:", err);
            showNotification("Error downloading PDF. Try again.");
          });
      }, 100);
    }
  </script>
</body>
</html>
