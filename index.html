<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Crossword Puzzle Generator</title>
  <style>
    :root {
      --primary-color: #00BCD4;
      --secondary-color: #007A87;
      --light-gray: #f5f5f5;
      --dark-gray: #333;
      --border-color: #ddd;
      --accent-color: #10B9AD; /* Education.com teal color */
      --green-border: #2A9D8F; /* Border color for worksheets */
    }
    * {
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    body {
      margin: 0;
      padding: 0;
      background-color: #fff;
      color: #333;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
    }
    header {
      padding: 20px 0;
      border-bottom: 1px solid var(--border-color);
    }
    h1 {
      color: var(--accent-color);
      margin: 0;
      font-size: 2.2rem;
    }
    h2 {
      color: #555;
      font-size: 1.8rem;
      font-weight: normal;
      margin-top: 0.5rem;
      margin-bottom: 2rem;
    }
    .content {
      display: flex;
      margin-top: 30px;
      gap: 40px;
    }
    .input-section {
      flex: 6;
    }
    .preview-section {
      flex: 5;
      background-color: var(--light-gray);
      padding: 20px;
      border-radius: 4px;
      position: relative;
    }
    .section-title {
      font-size: 1.5rem;
      margin-bottom: 15px;
      color: #444;
    }
    .help-text {
      margin-bottom: 20px;
      color: #666;
      font-size: 14px;
    }
    .title-input {
      width: 100%;
      padding: 12px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      margin-bottom: 20px;
      font-size: 16px;
    }
    .word-input {
      width: 100%;
      height: 400px;
      padding: 15px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      resize: vertical;
      font-size: 15px;
      font-family: monospace;
      line-height: 1.5;
    }
    .create-btn {
      background-color: var(--accent-color);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 12px 25px;
      cursor: pointer;
      font-size: 16px;
      margin-top: 20px;
      float: right;
      transition: background-color 0.2s;
    }
    .create-btn:hover {
      opacity: 0.9;
    }
    .preview-tabs {
      display: flex;
      margin-bottom: 0;
    }
    .preview-tab {
      padding: 10px 25px;
      cursor: pointer;
      background-color: #e0e0e0;
      border: none;
      font-weight: bold;
      font-size: 14px;
      border-radius: 3px 3px 0 0;
    }
    .preview-tab.active {
      background-color: #fff;
    }
    .preview-content {
      background-color: white;
      border-radius: 4px;
      padding: 20px;
      text-align: center;
      margin: 0 auto;
    }
    .worksheet-container {
      border: 2px solid var(--green-border);
      padding: 20px;
      border-radius: 4px;
      background-color: white;
      display: inline-block;
      min-width: 80%;
      margin: 0 auto;
    }
    .preview-title {
      margin-bottom: 25px;
      font-size: 22px;
      font-weight: bold;
      text-align: center;
    }
    .download-section {
      margin-top: 20px;
    }
    .download-btn {
      background-color: #4A6FDE; /* Education.com blue color for buttons */
      color: white;
      border: none;
      border-radius: 4px;
      padding: 12px 15px;
      cursor: pointer;
      margin: 5px;
      display: block;
      width: 100%;
      text-align: center;
      font-size: 14px;
      transition: background-color 0.2s;
      font-weight: bold;
    }
    .download-btn svg {
      margin-right: 5px;
    }
    .download-btn:hover {
      opacity: 0.9;
    }
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: var(--accent-color);
      color: white;
      padding: 15px 20px;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      transform: translateX(200%);
      transition: transform 0.3s ease-in-out;
      z-index: 1000;
    }
    .notification.show {
      transform: translateX(0);
    }
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      display: none;
    }
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top-color: var(--accent-color);
      animation: spin 1s ease-in-out infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* "Page preview" container */
    .page-preview {
      width: 500px;
      height: 708px;
      margin: 0 auto;
      position: relative;
      overflow: hidden;
    }
    
    /* Wrapper we can scale if puzzle is too large */
    .page-scale-wrapper {
      transform-origin: top left;
      position: absolute;
      left: 0;
      top: 0;
      width: auto;
      height: auto;
    }
    
    /* For PDF export - we'll hide this normally */
    .pdf-export-container {
      position: fixed;
      left: -9999px;
      top: -9999px;
      visibility: hidden;
    }
    .pdf-export-container.active {
      position: static;
      visibility: visible;
    }
    /* Make sure everything stays together in the PDF */
    .pdf-export-wrapper {
      page-break-inside: avoid !important;
      break-inside: avoid !important;
    }

    /* CROSSWORD LAYOUT */
    .crossword-grid-container {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
      width: 100%;
    }
    .crossword-grid {
      border-collapse: collapse;
      margin: 0 auto;
      margin-bottom: 20px;
    }
    .crossword-grid td {
      padding: 0;
    }
    .crossword-grid td:empty {
      background-color: #f3f3f3;
    }
    .crossword-cell {
      width: var(--cell-size, 25px);
      height: var(--cell-size, 25px);
      border: 1px solid #333;
      text-align: center;
      font-size: 16px;
      position: relative;
      background-color: white;
    }
    .cell-number {
      position: absolute;
      top: 1px;
      left: 2px;
      font-size: 9px;
      font-weight: normal;
    }
    .worksheet-heading {
      margin: 0 0 15px 0;
      text-align: left;
      font-weight: bold;
      font-size: 16px;
      color: #444;
    }
    .clues-container {
      margin-top: 30px;
      display: flex;
      flex-wrap: wrap;
      gap: 40px;
      text-align: left;
      justify-content: space-between;
    }
    .across-clues, .down-clues {
      flex: 1;
      min-width: 250px;
      max-width: 45%;
    }
    .clue-list {
      list-style-type: none;
      padding-left: 0;
    }
    .clue-item {
      margin-bottom: 12px;
      font-size: 14px;
      line-height: 1.5;
      text-align: left;
    }
    
    /* Footer with copyright */
    .footer {
      text-align: center;
      margin-top: 40px;
      padding: 20px 0;
      font-size: 12px;
      color: #666;
      border-top: 1px solid var(--border-color);
    }

    /* Education.com logo styling */
    .education-logo {
      display: block;
      text-align: right;
      margin-top: 20px;
    }

    /* PRINT STYLES */
    @media print {
      @page {
        size: A4;
        margin: 10mm;
      }
      body, html {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        font-size: 10pt;
      }
      .container, .input-section, .tabs, header,
      .create-btn, .preview-tabs, .download-section, .page-preview, .footer {
        display: none !important;
      }
      .preview-section {
        width: 100% !important;
        background: none;
        padding: 0;
        margin: 0;
        box-shadow: none;
      }
      .pdf-export-container {
        position: static !important;
        visibility: visible !important;
      }
      .pdf-export-container .crossword-grid-container {
        display: flex !important;
        justify-content: center !important;
        margin-bottom: 5mm !important;
      }
      .pdf-export-container .crossword-cell {
        width: 7mm;
        height: 7mm;
        border: 0.5pt solid black !important;
        font-size: 12pt;
      }
      .pdf-export-container .cell-number {
        font-size: 6pt;
      }
      .pdf-export-container .clues-container {
        display: block !important;
        column-count: 2;
        column-gap: 5mm;
        width: 100%;
        margin-top: 5mm !important;
        page-break-before: avoid !important;
        page-break-inside: avoid !important;
        break-inside: avoid !important;
      }
      
      .pdf-export-container .across-clues,
      .pdf-export-container .down-clues {
        display: block !important;
        break-inside: avoid !important;
        page-break-inside: avoid !important;
      }
      .pdf-export-container .worksheet-heading {
        font-size: 12pt;
        margin-bottom: 4mm;
      }
      .pdf-export-container .preview-title {
        font-size: 16pt;
        margin-bottom: 8mm;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Crossword Puzzle</h1>
      <h2>Reading worksheet generator</h2>
    </header>
    <div class="content">
      <div class="input-section">
        <h3 class="section-title">Enter crossword puzzle content</h3>
        <p class="help-text">See instructions below. Under 20 words is best for a single page.</p>
        
        <div>
          <label for="puzzleTitle">Title</label>
          <input type="text" id="puzzleTitle" class="title-input" value="Crossword Puzzle">
        </div>
        
        <div>
          <label for="wordsList">Words</label>
          <textarea id="wordsList" class="word-input"
            placeholder="Type or paste your list of words here. Format: term, definition (one per line)"></textarea>
        </div>
        
        <button class="create-btn" onclick="generateCrossword()">Create</button>
      </div>

      <div class="preview-section">
        <h3 class="section-title">Preview Worksheet</h3>
        <div class="preview-tabs">
          <button class="preview-tab active" onclick="showPreviewTab('worksheet')">WORKSHEET</button>
          <button class="preview-tab" onclick="showPreviewTab('answerKey')">ANSWER KEY</button>
        </div>
        
        <!-- The preview container -->
        <div class="page-preview">
          <!-- We'll scale the puzzle inside here if it's too large -->
          <div class="page-scale-wrapper" id="pageScaleWrapper">
            <div id="previewContent" class="preview-content">
              <div id="worksheetPreview">
                <div class="worksheet-container">
                  <h3 class="preview-title" id="previewTitle">Crossword Puzzle</h3>
                  <div id="crosswordContainer">
                    <p>Your puzzle will appear here after you create it.</p>
                  </div>
                </div>
                <div class="education-logo">
                  <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwIiBoZWlnaHQ9IjI1IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik02LjEzNyAxMy4zNjRjMCAzLjAwNSAyLjQzNiA1LjQ0MiA1LjQ0MiA1LjQ0MiAzLjAwNSAwIDUuNDQxLTIuNDM3IDUuNDQxLTUuNDQyIDAtMy4wMDYtMi40MzYtNS40NDItNS40NDEtNS40NDItMy4wMDYgMC01LjQ0MiAyLjQzNi01LjQ0MiA1LjQ0MnptMi42NDIuNDQySDkuNHYxLjY0MmgyLjE3OXYxLjMyMUgxNC4xVjE1LjQ0OGgxLjY0MlYxMy44MDVoLTIuNjIxdi0xLjMySDEwLjZ2MS4zMkg5LjQwMWwuMDAxLTEuMzJINy43Nzl2MS4zMnoiIGZpbGw9IiMwMGM2YmUiLz48cGF0aCBkPSJNMzguNDI4IDEwLjA0MmMtLjYzLS42MzQtMS4zODgtLjk1MS0yLjI3NC0uOTUxLS44ODEgMC0xLjYzNy4zMTgtMi4yNjguLzk1Ni0uNjMuNjM3LS45NDcgMS40MDQtLjk0NyAyLjMwMiAwIC44OTguMzE2IDEuNjY1Ljk0NyAyLjMwMi42MzEuNjM4IDEuMzg3Ljk1NiAyLjI2OC45NTYuODY4IDAgMS42MjMtLjMxOCAyLjI2My0uOTU2LjY0LS42MzcuOTYtMS40MDQuOTYtMi4zMDIgMC0uODk4LS4zMi0xLjY2NS0uOTYtMi4zMDJsLjAxMS0uMDA1em0tLjgyNiAzLjc1NGMtLjQwNi40MDYtLjg5NC42MS0xLjQ2LjYxLS41NyAwLTEuMDU5LS4yMDQtMS40NjUtLjYxLS40MDctLjQwNy0uNjExLS44OTgtLjYxMS0xLjQ3MiAwLS41NzUuMjA0LTEuMDY1LjYxLTEuNDcyLjQwNy0uNDA2Ljg5Ni0uNjEgMS40NjYtLjYxLjU2NyAwIDEuMDU0LjIwNCAxLjQ2LjYxLjQwOC40MDcuNjExLjg5Ny42MTEgMS40NzIgMCAuNTc0LS4yMDMgMS4wNjUtLjYxMSAxLjQ3MnptMzYuMTkzLTMuNzU0Yy0uNjMtLjYzNC0xLjM4Ny0uOTUxLTIuMjczLS45NTEtLjg4MiAwLTEuNjM4LjMxOC0yLjI2OC45NTYtLjYzMS42MzctLjk0NyAxLjQwNC0uOTQ3IDIuMzAyIDAgLjg5OC4zMTYgMS42NjUuOTQ3IDIuMzAyLjYzLjYzOCAxLjM4Ni45NTYgMi4yNjguOTU2Ljg2NyAwIDEuNjIyLS4zMTggMi4yNjItLjk1Ni42NC0uNjM3Ljk2LTEuNDA0Ljk2LTIuMzAyIDAtLjg5OC0uMzItMS42NjUtLjk2LTIuMzAybC4wMTEtLjAwNXptLS44MjUgMy43NTRjLS40MDYuNDA2LS44OTQuNjEtMS40Ni42MS0uNTcgMC0xLjA1OC0uMjA0LTEuNDY1LS42MS0uNDA3LS40MDctLjYxMS0uODk4LS42MTEtMS40NzIgMC0uNTc1LjIwNC0xLjA2NS42MTEtMS40NzIuNDA3LS40MDYuODk2LS42MSAxLjQ2NS0uNjEuNTY2IDAgMS4wNTQuMjA0IDEuNDYuNjEuNDA3LjQwNy42MTEuODk3LjYxMSAxLjQ3MiAwIC41NzQtLjIwNCAxLjA2NS0uNjExIDEuNDcyek0yNS43OTkgOC4zODRsLTIuMzUgNS44MDEtMi4zNzMtNS44MDFoLTEuNDYybC0yLjQxMyA1LjgwMS0yLjI2My01LjgwMWgtMS45MzFsMy4yMzIgOC4xNmgxLjY2MWwyLjM0OC01LjY5MyAyLjM0OCA1LjY5MmgxLjYxN2wzLjExLTguMTU5aC0xLjUyNHptMjIuMzY2IDMuMDAybDIuOTA3LTMuMDAxaC0xLjc2NmwtMi40NTggMi42MDdWOC4zODRoLTEuNTI0djguMTU5aDEuNTI0di0zLjQyOGwyLjYzNyAzLjQyOGgxLjgzMWwtMy4xNTEtNC4xMnptMjkuMzAzLTMuMDRoLTEuNTM4djEuODhoLTEuMDg2djEuMTg2aDEuMDg2djUuMTMzaDEuNTM4VjExLjQxM2gxLjg2MnYtMS4xODdINzcuNDd2LTEuODh6bTUuMzgtLjAyNWMtMS41MjQgMC0yLjcxNi40NzItMy41MjYgMS40MjlsMS4wMyAxLjA0Yy41MzQtLjY1MiAxLjI3OS0uOTc3IDIuMjMzLS45NzcuNDc4IDAgLjg2NS4xMjcgMS4xNjEuMzg1LjMuMjYuNDQyLjYxLjQyNiAxLjA1MWgtMS42ODhjLTEuMTMzIDAtMi4wMS4yNjMtMi42MjYuNzkzLS42MTcuNTI5LS45MjIgMS4yNDQtLjkyMiAyLjE0N2EyLjQ3IDIuNDcgMCAwIDAgLjc4NCAxLjg1M2MuNTI0LjQ5NyAxLjE5NS43NDYgMi4wMi43NDYuODAyIDAgMS4zOTctLjM0OCAxLjc4OC0xLjA0M2wuMTI2LS4wMDFoLjI2MnYuODM4aDEuNDMzdi01LjE5NGMwLS45NTYtLjI5My0xLjY5My0uODc4LTIuMjE4LS41ODQtLjUyNS0xLjM4Mi0uNzg5LTIuMzkzLS43ODl2LS4wMDV6bS43ODcgNC4zNTJ2LjQyYzAgLjQ5OS0uMTY4LjkwMy0uNTA0IDEuMjEzLS4zMzcuMzEtLjc2NC40NjctMS4yOC40NjctLjMzNiAwLS42MTEtLjA5Mi0uODIzLS4yNzYtLjIxMy0uMTg0LS4zMi0uNDI4LS4zMi0uNzM1IDAtLjMyMy4xMzctLjU4Ny40MS0uNzg5LjI3My0uMi42NDYtLjMuMS0uMyAxLjA3IDB6TTQ5LjQ5IDkuMjZjLS42NS0uNjE1LTEuNTQzLS45MzItMi42ODYtLjk0OWwtLjAwOC4wMDZoLTIuNjl2OC4yMjZoMS41MzZWMTMuNDNoMS4xNTRjMS4xNDMtLjAxNyAyLjAzNi0uMzM0IDIuNjg2LS45NDkuNjQtLjYxLjk2Mi0xLjQxMi45NjItMi40MDQgMC0uOTkzLS4zMjItMS43OTUtLjk2Ny0yLjQwOWwuMDEzLS40MDd6bS0xLjA3MSAzLjc0OGMtLjM1Mi4zNTItLjg0NC41MjgtMS40NzYuNTI4aC0xLjMwMlY5Ljc0MWgxLjMwMWMuNjMzIDAgMS4xMjQuMTc2IDEuNDc3LjUyOC4zNTIuMzUyLjUyOC44MzIuNTI4IDEuNDQgMCAuNjA3LS4xNzYgMS4wODctLjUyOCAxLjQ0em0yNi41NzItNC42MjRoLTEuNTM4djguMTU5aDUuMTg2di0xLjNINzUuMDV2LTYuODU5aC0uMDU4em0yOS4xNjUgMGgtMS41Mzh2OC4xNTloNS4xODZ2LTEuM2gtMy42NDl2LTYuODU5aC0uMDY5bC4wNyAwek05Mi43MDYgOS4yNmMtLjY1LS42MTUtMS41NDMtLjkzMi0yLjY4Ni0uOTQ5bC0uMDA5LjAwNmgtMi42OXY4LjIyNmgxLjUzN1YxMy40M2gxLjE1M2MxLjE0My0uMDE3IDIuMDM2LS4zMzQgMi42ODYtLjk0OS42NC0uNjEuOTYzLTEuNDEyLjk2My0yLjQwNCAwLS45OTMtLjMyMy0xLjc5NS0uOTY4LTIuNDA5bC4wMTQtLjQwN3ptLTEuMDcxIDMuNzQ4Yy0uMzUyLjM1Mi0uODQ1LjUyOC0xLjQ3Ny41MjhoLTEuM1Y5Ljc0MWgxLjNjLjYzMyAwIDEuMTI1LjE3NiAxLjQ3Ny41MjguMzUyLjM1Mi41MjguODMyLjUyOCAxLjQ0IDAgLjYwNy0uMTc2IDEuMDg3LS41MjggMS40NHptNi4xNS01LjY4N2MuMzc2IDAgLjY4My0uMzA2LjY4My0uNjgycy0uMzA2LS42ODItLjY4My0uNjgyYy0uMzc2IDAtLjY4Mi4zMDYtLjY4Mi42ODJzLjMwNi42ODIuNjgyLjY4MnptLS43NjkgMS45MzhoMS41Mzl2OC4xNTlINDcuMDMyTDk3LjAxNiA5LjI2em0xOC4yMzQtLjE3M2MtLjY1LS42MTUtMS41NDItLjkzMi0yLjY4NS0uOTQ5bC0uMDA4LjAwNmgtMi42OXY4LjIyNmgxLjUzN1YxMy40M2gxLjE1M2MxLjE0My0uMDE3IDIuMDM2LS4zMzQgMi42ODUtLjk0OS42NC0uNjEuOTYzLTEuNDEyLjk2My0yLjQwNCAwLS45OTMtLjMyMi0xLjc5NS0uOTY3LTIuNDA5bC4wMTItLjQwN3ptLTEuMDcgMy43NDhjLS4zNTIuMzUyLS44NDUuNTI4LTEuNDc3LjUyOGgtMS4zVjkuNzQxaDEuM2MuNjMzIDAgMS4xMjUuMTc2IDEuNDc3LjUyOC4zNTIuMzUyLjUyOC44MzIuNTI4IDEuNDQgMCAuNjA3LS4xNzYgMS4wODctLjUyOCAxLjQ0em03LjQ0Mi00LjQ1MmwtMi4zNSA1LjgwMS0yLjM3My01LjgwMWgtMS40NjJsLTIuNDEzIDUuODAxLTIuMjY0LTUuODAxaC0xLjkzbDMuMjMyIDguMTZoMS42NmwyLjM0OC01LjY5MyAyLjM0OSA1LjY5MmgxLjYxN2wzLjExLTguMTU5aC0xLjUyM3ptLTMyLjA4MS01LjI4YS43MjIuNzIyIDAgMCAwLS43MjItLjcyMy43M
<div class="education-logo">
                  <svg xmlns="http://www.w3.org/2000/svg" width="120" height="25" viewBox="0 0 120 25" fill="none">
                    <path d="M6.137 13.364c0 3.005 2.436 5.442 5.442 5.442 3.005 0 5.441-2.437 5.441-5.442 0-3.006-2.436-5.442-5.441-5.442-3.006 0-5.442 2.436-5.442 5.442zm2.642.442H9.4v1.642h2.179v1.321H14.1V15.448h1.642V13.805h-2.621v-1.32H10.6v1.32H9.401l.001-1.32H7.779v1.32z" fill="#00c6be"/>
                    <path d="M38.428 10.042c-.63-.634-1.388-.951-2.274-.951-.881 0-1.637.318-2.268.956-.63.637-.947 1.404-.947 2.302 0 .898.316 1.665.947 2.302.631.638 1.387.956 2.268.956.868 0 1.623-.318 2.263-.956.64-.637.96-1.404.96-2.302 0-.898-.32-1.665-.96-2.302l.011-.005zm-.826 3.754c-.406.406-.894.61-1.46.61-.57 0-1.059-.204-1.465-.61-.407-.407-.611-.898-.611-1.472 0-.575.204-1.065.61-1.472.407-.406.896-.61 1.466-.61.567 0 1.054.204 1.46.61.408.407.611.897.611 1.472 0 .574-.203 1.065-.611 1.472zm36.193-3.754c-.63-.634-1.387-.951-2.273-.951-.882 0-1.638.318-2.268.956-.631.637-.947 1.404-.947 2.302 0 .898.316 1.665.947 2.302.63.638 1.386.956 2.268.956.867 0 1.622-.318 2.262-.956.64-.637.96-1.404.96-2.302 0-.898-.32-1.665-.96-2.302l.011-.005zm-.825 3.754c-.406.406-.894.61-1.46.61-.57 0-1.058-.204-1.465-.61-.407-.407-.611-.898-.611-1.472 0-.575.204-1.065.611-1.472.407-.406.896-.61 1.465-.61.566 0 1.054.204 1.46.61.407.407.611.897.611 1.472 0 .574-.204 1.065-.611 1.472z" fill="#00c6be"/>
                    <path d="M25.799 8.384l-2.35 5.801-2.373-5.801h-1.462l-2.413 5.801-2.263-5.801h-1.931l3.232 8.16h1.661l2.348-5.693 2.348 5.692h1.617l3.11-8.159h-1.524zm22.366 3.002l2.907-3.001h-1.766l-2.458 2.607V8.384h-1.524v8.159h1.524v-3.428l2.637 3.428h1.831l-3.151-4.12zm29.303-3.04h-1.538v1.88h-1.086v1.186h1.086v5.133h1.538V11.413h1.862v-1.187H77.47v-1.88zm5.38-.025c-1.524 0-2.716.472-3.526 1.429l1.03 1.04c.534-.652 1.279-.977 2.233-.977.478 0 .865.127 1.161.385.3.26.442.61.426 1.051h-1.688c-1.133 0-2.01.263-2.626.793-.617.529-.922 1.244-.922 2.147a2.47 2.47 0 0 0 .784 1.853c.524.497 1.195.746 2.02.746.802 0 1.397-.348 1.788-1.043l.126-.001h.262v.838h1.433v-5.194c0-.956-.293-1.693-.878-2.218-.584-.525-1.382-.789-2.393-.789v-.005zm.787 4.352v.42c0 .499-.168.903-.504 1.213-.337.31-.764.467-1.28.467-.336 0-.611-.092-.823-.276-.213-.184-.32-.428-.32-.735 0-.323.137-.587.41-.789.273-.2.646-.3.1-.3 1.07 0 .417 0 .417 0zm-33.647-4.413c-.65-.615-1.543-.932-2.686-.949l-.008.006h-2.69v8.226h1.536V13.43h1.154c1.143-.017 2.036-.334 2.686-.949.64-.61.962-1.412.962-2.404 0-.993-.322-1.795-.967-2.409l.013-.407zm-1.071 3.748c-.352.352-.844.528-1.476.528h-1.302V9.741h1.301c.633 0 1.124.176 1.477.528.352.352.528.832.528 1.44 0 .607-.176 1.087-.528 1.44zm26.572-4.624h-1.538v8.159h5.186v-1.3H75.05V8.384h-.058zm29.165 0h-1.538v8.159h5.186v-1.3h-3.649V8.384h-.069l.07 0zm-9.629.876c-.65-.615-1.543-.932-2.686-.949l-.009.006h-2.69v8.226h1.537V13.43h1.153c1.143-.017 2.036-.334 2.686-.949.64-.61.963-1.412.963-2.404 0-.993-.323-1.795-.968-2.409l.014-.407zm-1.071 3.748c-.352.352-.845.528-1.477.528h-1.3V9.741h1.3c.633 0 1.125.176 1.477.528.352.352.528.832.528 1.44 0 .607-.176 1.087-.528 1.44zm6.15-5.687c.376 0 .683-.306.683-.682s-.306-.682-.683-.682c-.376 0-.682.306-.682.682s.306.682.682.682zm-.769 1.938h1.539v8.159h-1.539z" fill="#00c6be"/>
                    <path d="M115.25 9.087c-.65-.615-1.542-.932-2.685-.949l-.008.006h-2.69v8.226h1.537V13.43h1.153c1.143-.017 2.036-.334 2.685-.949.64-.61.963-1.412.963-2.404 0-.993-.322-1.795-.967-2.409l.012-.407zm-1.07 3.748c-.352.352-.845.528-1.477.528h-1.3V9.741h1.3c.633 0 1.125.176 1.477.528.352.352.528.832.528 1.44 0 .607-.176 1.087-.528 1.44z" fill="#00c6be"/>
                  </svg>
                </div>
              </div>
              <div id="answerKeyPreview" style="display: none;">
                <div class="worksheet-container">
                  <h3 class="preview-title" id="answerKeyTitle">Crossword Puzzle</h3>
                  <div id="answerKeyContainer">
                    <p>Your answer key will appear here after you create it.</p>
                  </div>
                </div>
                <div class="education-logo">
                  <svg xmlns="http://www.w3.org/2000/svg" width="120" height="25" viewBox="0 0 120 25" fill="none">
                    <path d="M6.137 13.364c0 3.005 2.436 5.442 5.442 5.442 3.005 0 5.441-2.437 5.441-5.442 0-3.006-2.436-5.442-5.441-5.442-3.006 0-5.442 2.436-5.442 5.442zm2.642.442H9.4v1.642h2.179v1.321H14.1V15.448h1.642V13.805h-2.621v-1.32H10.6v1.32H9.401l.001-1.32H7.779v1.32z" fill="#00c6be"/>
                    <path d="M38.428 10.042c-.63-.634-1.388-.951-2.274-.951-.881 0-1.637.318-2.268.956-.63.637-.947 1.404-.947 2.302 0 .898.316 1.665.947 2.302.631.638 1.387.956 2.268.956.868 0 1.623-.318 2.263-.956.64-.637.96-1.404.96-2.302 0-.898-.32-1.665-.96-2.302l.011-.005zm-.826 3.754c-.406.406-.894.61-1.46.61-.57 0-1.059-.204-1.465-.61-.407-.407-.611-.898-.611-1.472 0-.575.204-1.065.61-1.472.407-.406.896-.61 1.466-.61.567 0 1.054.204 1.46.61.408.407.611.897.611 1.472 0 .574-.203 1.065-.611 1.472zm36.193-3.754c-.63-.634-1.387-.951-2.273-.951-.882 0-1.638.318-2.268.956-.631.637-.947 1.404-.947 2.302 0 .898.316 1.665.947 2.302.63.638 1.386.956 2.268.956.867 0 1.622-.318 2.262-.956.64-.637.96-1.404.96-2.302 0-.898-.32-1.665-.96-2.302l.011-.005zm-.825 3.754c-.406.406-.894.61-1.46.61-.57 0-1.058-.204-1.465-.61-.407-.407-.611-.898-.611-1.472 0-.575.204-1.065.611-1.472.407-.406.896-.61 1.465-.61.566 0 1.054.204 1.46.61.407.407.611.897.611 1.472 0 .574-.204 1.065-.611 1.472z" fill="#00c6be"/>
                    <path d="M25.799 8.384l-2.35 5.801-2.373-5.801h-1.462l-2.413 5.801-2.263-5.801h-1.931l3.232 8.16h1.661l2.348-5.693 2.348 5.692h1.617l3.11-8.159h-1.524zm22.366 3.002l2.907-3.001h-1.766l-2.458 2.607V8.384h-1.524v8.159h1.524v-3.428l2.637 3.428h1.831l-3.151-4.12zm29.303-3.04h-1.538v1.88h-1.086v1.186h1.086v5.133h1.538V11.413h1.862v-1.187H77.47v-1.88zm5.38-.025c-1.524 0-2.716.472-3.526 1.429l1.03 1.04c.534-.652 1.279-.977 2.233-.977.478 0 .865.127 1.161.385.3.26.442.61.426 1.051h-1.688c-1.133 0-2.01.263-2.626.793-.617.529-.922 1.244-.922 2.147a2.47 2.47 0 0 0 .784 1.853c.524.497 1.195.746 2.02.746.802 0 1.397-.348 1.788-1.043l.126-.001h.262v.838h1.433v-5.194c0-.956-.293-1.693-.878-2.218-.584-.525-1.382-.789-2.393-.789v-.005zm.787 4.352v.42c0 .499-.168.903-.504 1.213-.337.31-.764.467-1.28.467-.336 0-.611-.092-.823-.276-.213-.184-.32-.428-.32-.735 0-.323.137-.587.41-.789.273-.2.646-.3.1-.3 1.07 0 .417 0 .417 0zm-33.647-4.413c-.65-.615-1.543-.932-2.686-.949l-.008.006h-2.69v8.226h1.536V13.43h1.154c1.143-.017 2.036-.334 2.686-.949.64-.61.962-1.412.962-2.404 0-.993-.322-1.795-.967-2.409l.013-.407zm-1.071 3.748c-.352.352-.844.528-1.476.528h-1.302V9.741h1.301c.633 0 1.124.176 1.477.528.352.352.528.832.528 1.44 0 .607-.176 1.087-.528 1.44zm26.572-4.624h-1.538v8.159h5.186v-1.3H75.05V8.384h-.058zm29.165 0h-1.538v8.159h5.186v-1.3h-3.649V8.384h-.069l.07 0zm-9.629.876c-.65-.615-1.543-.932-2.686-.949l-.009.006h-2.69v8.226h1.537V13.43h1.153c1.143-.017 2.036-.334 2.686-.949.64-.61.963-1.412.963-2.404 0-.993-.323-1.795-.968-2.409l.014-.407zm-1.071 3.748c-.352.352-.845.528-1.477.528h-1.3V9.741h1.3c.633 0 1.125.176 1.477.528.352.352.528.832.528 1.44 0 .607-.176 1.087-.528 1.44zm6.15-5.687c.376 0 .683-.306.683-.682s-.306-.682-.683-.682c-.376 0-.682.306-.682.682s.306.682.682.682zm-.769 1.938h1.539v8.159h-1.539z" fill="#00c6be"/>
                    <path d="M115.25 9.087c-.65-.615-1.542-.932-2.685-.949l-.008.006h-2.69v8.226h1.537V13.43h1.153c1.143-.017 2.036-.334 2.685-.949.64-.61.963-1.412.963-2.404 0-.993-.322-1.795-.967-2.409l.012-.407zm-1.07 3.748c-.352.352-.845.528-1.477.528h-1.3V9.741h1.3c.633 0 1.125.176 1.477.528.352.352.528.832.528 1.44 0 .607-.176 1.087-.528 1.44z" fill="#00c6be"/>
                  </svg>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="download-section">
          <button class="download-btn" onclick="printPuzzle()">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
              <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
              <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
            </svg>
            Download Worksheet
          </button>
          
          <button class="download-btn" onclick="printAnswerKey()">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
              <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
              <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
            </svg>
            Download Answer Key
          </button>
        </div>
      </div>
    </div>
    
    <!-- Footer with copyright -->
    <div class="footer">
      made with ❤️ by Shandé
    </div>
  </div>

  <!-- Hidden containers for PDF export (no scaling applied) -->
  <div id="pdfWorksheetContainer" class="pdf-export-container"></div>
  <div id="pdfAnswerKeyContainer" class="pdf-export-container"></div>

  <div class="notification" id="notification">Notification message</div>
  <div class="loading-overlay" id="loadingOverlay">
    <div class="spinner"></div>
  </div>

  <!-- html2pdf -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script>
    // Global variables
    let generatedPuzzle = null;
    let currentPreviewTab = 'worksheet';
    
    // Example placeholder
    window.onload = function() {
      const wordsList = document.getElementById('wordsList');
      if (!wordsList.value) {
        wordsList.placeholder = 
`to burn, to be on fire or to cause something to be on fire
burn, an injury caused by fire or heat
to save, to stop something from being damaged or destroyed
to scream, to make a loud, high sound because of fear or pain
to shout, to speak very loudly
to rescue, to save someone from danger
to survive, to continue to live after dangerous situation
alarm, a device that makes a loud noise to warn of danger
embers, glowing remnants of a dying fire
ignite, to catch fire or to set something alight
extinguisher, a device used to put out fires
rescue team, a group of people trained to save others in emergencies
soot, a black, powdery substance produced by fire
hazard, a danger or risk that has the potential to cause harm
evacuation, the process of moving people away from danger to safety
caution, careful behavior to avoid danger or mistakes
emergency, a sudden, urgent situation requiring immediate action`;
      }
    };

    function showPreviewTab(tabName) {
      currentPreviewTab = tabName;
      const previewTabs = document.getElementsByClassName("preview-tab");
      for (let i = 0; i < previewTabs.length; i++) {
        previewTabs[i].classList.remove("active");
      }
      document.querySelector(`.preview-tab[onclick="showPreviewTab('${tabName}')"]`)
              .classList.add("active");

      // Show/hide the correct preview
      if (tabName === 'worksheet') {
        document.getElementById('worksheetPreview').style.display = 'block';
        document.getElementById('answerKeyPreview').style.display = 'none';
      } else {
        document.getElementById('worksheetPreview').style.display = 'none';
        document.getElementById('answerKeyPreview').style.display = 'block';
      }
      updatePreviewScale();
    }
    
    function showNotification(message) {
      const notification = document.getElementById("notification");
      notification.textContent = message;
      notification.classList.add("show");
      setTimeout(() => {
        notification.classList.remove("show");
      }, 3000);
    }
    
    function showLoading(show) {
      document.getElementById("loadingOverlay").style.display = show ? "flex" : "none";
    }
    
    // Scale the puzzle to fit within .page-preview
    function updatePreviewScale() {
      const previewWrapper = document.querySelector('.page-preview');
      const scaleWrapper = document.getElementById('pageScaleWrapper');
      // reset scale so we measure "actual" size
      scaleWrapper.style.transform = 'scale(1)';

      const maxW = previewWrapper.clientWidth;
      const maxH = previewWrapper.clientHeight;
      const contentW = scaleWrapper.scrollWidth;
      const contentH = scaleWrapper.scrollHeight;

      let scale = 1;
      if (contentW && contentH) {
        const scaleW = maxW / contentW;
        const scaleH = maxH / contentH;
        scale = Math.min(scaleW, scaleH, 1);
      }
      scaleWrapper.style.transform = `scale(${scale})`;
    }

    // Parse user input
    function parseWordsInput() {
      const wordsText = document.getElementById('wordsList').value.trim();
      const lines = wordsText.split('\n');
      const words = [];
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;

        const firstCommaIndex = line.indexOf(',');
        if (firstCommaIndex === -1) {
          showNotification("Line " + (i + 1) + " is missing a definition. Format: term, definition");
          return null;
        }

        const term = line.substring(0, firstCommaIndex).trim().toUpperCase();
        const definition = line.substring(firstCommaIndex + 1).trim();
        const cleanTerm = term.replace(/[^A-Z]/g, "");
        if (cleanTerm.length < 2) {
          showNotification("Term '" + term + "' is too short (2+ letters).");
          return null;
        }
        words.push({ word: cleanTerm, clue: definition });
      }
      if (words.length < 3) {
        showNotification("Please enter at least 3 terms with definitions");
        return null;
      }
      if (words.length > 20) { // Increased from 16 to 20
        showNotification("Too many terms. Please limit to 20 for best layout.");
        return null;
      }
      return words;
    }

    // Generate puzzle
    function generateCrossword() {
      showLoading(true);
      setTimeout(() => {
        try {
          const words = parseWordsInput();
          if (!words) {
            showLoading(false);
            return;
          }
          const puzzleTitle = document.getElementById('puzzleTitle').value || "Crossword Puzzle";
          document.getElementById('previewTitle').textContent = puzzleTitle;
          document.getElementById('answerKeyTitle').textContent = puzzleTitle;

          try {
            generatedPuzzle = createCrosswordGrid(words);
            renderCrossword(generatedPuzzle, false); // Worksheet
            renderCrossword(generatedPuzzle, true);  // Answer Key
            showPreviewTab('worksheet');
          } catch (err) {
            console.error(err);
            showNotification("Error generating crossword. Try different terms.");
          }
        } catch (err) {
          console.error(err);
          showNotification("Error processing input. Check format.");
        } finally {
          showLoading(false);
        }
      }, 100);
    }

    // IMPROVED CROSSWORD ALGORITHM
    function createCrosswordGrid(words) {
      // Sort words by length descending
      words.sort((a, b) => b.word.length - a.word.length);
      
      // IMPROVEMENT 1: Try multiple layouts and score them
      const attempts = 8; // Generate 8 different layouts
      let bestLayout = null;
      let bestScore = -Infinity;
      
      for (let attempt = 0; attempt < attempts; attempt++) {
        try {
          const layout = generateLayout(words, attempt);
          if (!layout) continue; // Skip if the layout couldn't be generated
          
          const score = scoreLayout(layout);
          if (score > bestScore) {
            bestScore = score;
            bestLayout = layout;
          }
        } catch (e) {
          console.log("Layout attempt failed:", e);
          // Continue to next attempt
        }
      }
      
      // If we found a good layout, use it
      if (bestLayout && bestLayout.placedWords.length >= Math.min(words.length * 0.8, words.length)) {
        return bestLayout;
      }
      
      // Fallback to original algorithm if no good layout was found
      return generateOriginalLayout(words);
    }

// IMPROVEMENT 3: Score a layout based on multiple factors
    function scoreLayout(layout) {
      // Count across and down words
      let acrossCount = 0;
      let downCount = 0;
      layout.placedWords.forEach(word => {
        if (word.horizontal) acrossCount++;
        else downCount++;
      });
      
      // Calculate grid dimensions
      const height = layout.grid.length;
      const width = layout.grid[0].length;
      
      // Calculate aspect ratio and how "square" the grid is
      const aspectRatio = width / height;
      const squareness = Math.min(aspectRatio, 1/aspectRatio); // 1.0 is perfectly square
      
      // Calculate balance between across and down words
      const directionBalance = Math.min(acrossCount, downCount) / Math.max(acrossCount, downCount);
      
      // Calculate percentage of words placed
      const wordPlacementRatio = layout.placedWords.length / layout.totalWords;
      
      // Calculate intersections density (intersections per word)
      let intersections = 0;
      for (let i = 0; i < layout.placedWords.length; i++) {
        for (let j = i + 1; j < layout.placedWords.length; j++) {
          if (wordsIntersect(layout.placedWords[i], layout.placedWords[j])) {
            intersections++;
          }
        }
      }
      const intersectionDensity = intersections / Math.max(1, layout.placedWords.length);
      
      // Calculate overall score
      return (wordPlacementRatio * 40) + // Weight of word placement
             (squareness * 30) +          // Weight of grid shape
             (directionBalance * 20) +    // Weight of direction balance
             (intersectionDensity * 10);  // Weight of intersections
    }
    
    // Check if two words intersect
    function wordsIntersect(word1, word2) {
      // Words with same orientation can't intersect
      if (word1.horizontal === word2.horizontal) return false;
      
      const horizontal = word1.horizontal ? word1 : word2;
      const vertical = word1.horizontal ? word2 : word1;
      
      // Check if the horizontal word crosses the vertical word
      return horizontal.startX <= vertical.startX && 
             horizontal.startX + horizontal.word.length > vertical.startX &&
             vertical.startY <= horizontal.startY &&
             vertical.startY + vertical.word.length > horizontal.startY;
    }
    
    // Generate a layout with the given words
    function generateLayout(words, attemptNumber) {
      const gridSize = calculateGridSize(words);
      const grid = createEmptyGrid(gridSize);
      const placedWords = [];
      
      // IMPROVEMENT 2 & 4: Track direction balance and vary first word orientation
      let acrossCount = 0;
      let downCount = 0;
      
      // Alternate between horizontal and vertical for the first word
      const firstWordHorizontal = attemptNumber % 2 === 0;
      
      // Place first word
      const firstWord = words[0];
      const startX = Math.floor((gridSize - firstWord.word.length) / 2

// Generate a layout with the given words
    function generateLayout(words, attemptNumber) {
      const gridSize = calculateGridSize(words);
      const grid = createEmptyGrid(gridSize);
      const placedWords = [];
      
      // IMPROVEMENT 2 & 4: Track direction balance and vary first word orientation
      let acrossCount = 0;
      let downCount = 0;
      
      // Alternate between horizontal and vertical for the first word
      const firstWordHorizontal = attemptNumber % 2 === 0;
      
      // Place first word
      const firstWord = words[0];
      const startX = Math.floor((gridSize - firstWord.word.length) / 2);
      const startY = Math.floor(gridSize / 2);
      
      placeWordOnGrid(grid, firstWord.word, startX, startY, firstWordHorizontal);
      placedWords.push({
        word: firstWord.word,
        clue: firstWord.clue,
        startX: startX,
        startY: startY,
        horizontal: firstWordHorizontal
      });
      
      if (firstWordHorizontal) acrossCount++;
      else downCount++;
      
      // Add randomness by shuffling the word order for each attempt
      const remainingWords = [...words.slice(1)];
      if (attemptNumber > 0) {
        // Use a different shuffle pattern for each attempt
        for (let i = 0; i < attemptNumber; i++) {
          remainingWords.sort(() => Math.random() - 0.5);
        }
      }
      
      // Try to place each remaining word
      for (let i = 0; i < remainingWords.length; i++) {
        const currentWord = remainingWords[i];
        let placementFound = false;
        
        // IMPROVEMENT 2: Balance across and down words
        const preferHorizontal = acrossCount <= downCount;
        
        // Get all possible placements
        const possiblePlacements = findPossiblePlacements(grid, currentWord, placedWords, preferHorizontal);
        
        if (possiblePlacements.length > 0) {
          // IMPROVEMENT 5: Sort placements by intersection quality
          possiblePlacements.sort((a, b) => b.score - a.score);
          
          // Use the best placement
          const bestPlacement = possiblePlacements[0];
          placeWordOnGrid(grid, currentWord.word, bestPlacement.x, bestPlacement.y, bestPlacement.horizontal);
          placedWords.push({
            word: currentWord.word,
            clue: currentWord.clue,
            startX: bestPlacement.x,
            startY: bestPlacement.y,
            horizontal: bestPlacement.horizontal
          });
          
          if (bestPlacement.horizontal) acrossCount++;
          else downCount++;
          
          placementFound = true;
        }
        
        // If no placement found, move to the next word
        if (!placementFound) {
          continue;
        }
      }
      
      // Trim the grid to remove empty space
      const trimmed = trimGrid(grid);
      
      // Adjust word positions based on the trimmed grid
      const adjustX = trimmed.trimFromLeft;
      const adjustY = trimmed.trimFromTop;
      
      for (let i = 0; i < placedWords.length; i++) {
        placedWords[i].startX -= adjustX;
        placedWords[i].startY -= adjustY;
      }
      
      // Number the grid
      numberGrid(trimmed.grid, placedWords);
      
      // Separate clues into across and down
      const acrossClues = [];
      const downClues = [];
      
      for (let w of placedWords) {
        if (w.horizontal) {
          acrossClues.push({ number: w.number, clue: w.clue, word: w.word });
        } else {
          downClues.push({ number: w.number, clue: w.clue, word: w.word });
        }
      }
      
      acrossClues.sort((a, b) => a.number - b.number);
      downClues.sort((a, b) => a.number - b.number);
      
      return {
        grid: trimmed.grid,
        placedWords: placedWords,
        acrossClues,
        downClues,
        totalWords: words.length
      };
    }
    
    // Find all possible placements for a word
    function findPossiblePlacements(grid, currentWord, placedWords, preferHorizontal) {
      const possiblePlacements = [];
      
      // Try both orientations, but prioritize the preferred one
      const orientations = preferHorizontal ? 
            [{ horizontal: true }, { horizontal: false }] : 
            [{ horizontal: false }, { horizontal: true }];
      
      for (const orientation of orientations) {
        for (const placedWord of placedWords) {
          // Skip words with the same orientation if we're trying to balance
          if (placedWord.horizontal === orientation.horizontal && 
              (orientation.horizontal ? placedWords.filter(w => w.horizontal).length > placedWords.filter(w => !w.horizontal).length : 
                                        placedWords.filter(w => !w.horizontal).length > placedWords.filter(w => w.horizontal).length)) {
            continue;
          }
          
          for (let i = 0; i < currentWord.word.length; i++) {
            for (let j = 0; j < placedWord.word.length; j++) {
              if (currentWord.word[i] === placedWord.word[j]) {
                let x, y;
                
                if (orientation.horizontal) {
                  x = placedWord.startX + (placedWord.horizontal ? j : 0) - i;
                  y = placedWord.startY + (placedWord.horizontal ? 0 : j);
                } else {
                  x = placedWord.startX + (placedWord.horizontal ? j : 0);
                  y = placedWord.startY + (placedWord.horizontal ? 0 : j) - i;
                }
                
                if (canPlaceWord(grid, currentWord.word, x, y, orientation.horizontal)) {
                  // Calculate a score for this placement
                  const potentialScore = calculatePlacementScore(grid, currentWord.word, x, y, orientation.horizontal, placedWords);
                  
                  possiblePlacements.push({
                    x,
                    y,
                    horizontal: orientation.horizontal,
                    score: potentialScore,
                    intersectionPoint: { wordIndex: i, placedWordIndex: j }
                  });
                }
              }
            }
          }
        }
      }
      
      return possiblePlacements;
    }
    
    // Calculate a score for a potential word placement
    function calculatePlacementScore(grid, word, startX, startY, horizontal, placedWords) {
      let score = 0;
      
      // Score for number of intersections
      for (let i = 0; i < word.length; i++) {
        const x = horizontal ? startX + i : startX;
        const y = horizontal ? startY : startY + i;
        
        // If this position already has a letter, it's an intersection
        if (grid[y] && grid[y][x] === word[i]) {
          score += 5; // Bonus for each intersection
        }
      }
      
      // Penalty for expanding the grid too much
      const currentMaxX = Math.max(...placedWords.map(w => w.horizontal ? w.startX + w.word.length - 1 : w.startX));
      const currentMaxY = Math.max(...placedWords.map(w => w.horizontal ? w.startY : w.startY + w.word.length - 1));
      const currentMinX = Math.min(...placedWords.map(w => w.startX));
      const currentMinY = Math.min(...placedWords.map(w => w.startY));
      
      const newMaxX = horizontal ? startX + word.length - 1 : startX;
      const newMaxY = horizontal ? startY : startY + word.length - 1;
      
      // Calculate how much this placement expands the grid
      const expansion = Math.max(0, newMaxX - currentMaxX) + Math.max(0, newMaxY - currentMaxY) + 
                        Math.max(0, currentMinX - startX) + Math.max(0, currentMinY - startY);
      
      score -= expansion; // Penalty for expanding the grid
      
      // Bonus for placements that help balance the grid shape
      const currentWidth = currentMaxX - currentMinX + 1;
      const currentHeight = currentMaxY - currentMinY + 1;
      const currentRatio = currentWidth / currentHeight;
      
      const newWidth = Math.max(currentMaxX, newMaxX) - Math.min(currentMinX, startX) + 1;
      const newHeight = Math.max(currentMaxY, newMaxY) - Math.min(currentMinY, startY) + 1;
      const newRatio = newWidth / newHeight;
      
      // If the new ratio is closer to 1 (more square), give a bonus
      if (Math.abs(newRatio - 1) < Math.abs(currentRatio - 1)) {
        score += 3;
      }
      
      return score;
    }
    
    // Original layout generation for fallback
    function generateOriginalLayout(words) {
      const gridSize = calculateGridSize(words);
      const grid = createEmptyGrid(gridSize);
      const placedWords = [];

      // Place first word in the middle horizontally
      const firstWord = words[0];
      const startX = Math.floor((gridSize - firstWord.word.length) / 2);
      const startY = Math.floor(gridSize / 2);
      placeWordOnGrid(grid, firstWord.word, startX, startY, true);
      placedWords.push({
        word: firstWord.word,
        clue: firstWord.clue,
        startX: startX,
        startY: startY,
        horizontal: true
      });

      // Attempt to place remaining
      for (let i = 1; i < words.length; i++) {
        const currentWord = words[i];
        let placed = false;

        for (let j = 0; j < placedWords.length && !placed; j++) {
          const placedWord = placedWords[j];
          // horizontal intersection
          if (!placedWord.horizontal) {
            for (let charIndex = 0; charIndex < currentWord.word.length && !placed; charIndex++) {
              for (let pc = 0; pc < placedWord.word.length && !placed; pc++) {
                if (currentWord.word[charIndex] === placedWord.word[pc]) {
                  const newX = placedWord.startX - charIndex;
                  const newY = placedWord.startY + pc;
                  if (canPlaceWord(grid, currentWord.word, newX, newY, true)) {
                    placeWordOnGrid(grid, currentWord.word, newX, newY, true);
                    placedWords.push({
                      word: currentWord.word,
                      clue: currentWord.clue,
                      startX: newX,
                      startY: newY,
                      horizontal: true
                    });
                    placed = true;
                  }
                }
              }
            }
          }
          // vertical intersection
          if (placedWord.horizontal && !placed) {
            for (let charIndex = 0; charIndex < currentWord.word.length && !placed; charIndex++) {
              for (let pc = 0; pc < placedWord.word.length && !placed; pc++) {
                if (currentWord.word[charIndex] === placedWord.word[pc]) {
                  const newX = placedWord.startX + pc;
                  const newY = placedWord.startY - charIndex;
                  if (canPlaceWord(grid, currentWord.word, newX, newY, false)) {
                    placeWordOnGrid(grid, currentWord.word, newX, newY, false);
                    placedWords.push({
                      word: currentWord.word,
                      clue: currentWord.clue,
                      startX: newX,
                      startY: newY,
                      horizontal: false
                    });
                    placed = true;
                  }
                }
              }
            }
          }
        }
      }
      
      // Trim the grid
      const trimmed = trimGrid(grid);
      
      // Adjust word positions based on the trimmed grid
      const adjustX = trimmed.trimFromLeft;
      const adjustY = trimmed.trimFromTop;
      
      for (let i = 0; i < placedWords.length; i++) {
        placedWords[i].startX -= adjustX;
        placedWords[i].startY -= adjustY;
      }
      
      // Number the grid
      numberGrid(trimmed.grid, placedWords);
      
      // Prepare clues
      const acrossClues = [];
      const downClues = [];
      
      for (let w of placedWords) {
        if (w.horizontal) {
          acrossClues.push({ number: w.number, clue: w.clue, word: w.word });
        } else {
          downClues.push({ number: w.number, clue: w.clue, word: w.word });
        }
      }
      
      acrossClues.sort((a, b) => a.number - b.number);
      downClues.sort((a, b) => a.number - b.number);
      
      return {
        grid: trimmed.grid,
        placedWords: placedWords,
        acrossClues,
        downClues,
        totalWords: words.length
      };
    }

    function calculateGridSize(words) {
      let maxLength = 0;
      for (let w of words) {
        maxLength = Math.max(maxLength, w.word.length);
      }
      // some padding
      return Math.max(20, maxLength + 10);
    }

    function createEmptyGrid(size) {
      const g = [];
      for (let y = 0; y < size; y++) {
        g[y] = [];
        for (let x = 0; x < size; x++) {
          g[y][x] = null;
        }
      }
      return g;
    }

    function canPlaceWord(grid, word, startX, startY, horizontal) {
      const gridSize = grid.length;
      if (horizontal) {
        if (startX < 0 || startX + word.length > gridSize || startY < 0 || startY >= gridSize) {
          return false;
        }
      } else {
        if (startX < 0 || startX >= gridSize || startY < 0 || startY + word.length > gridSize) {
          return false;
        }
      }
      let hasIntersection = false;
      for (let i = 0; i < word.length; i++) {
        const x = horizontal ? startX + i : startX;
        const y = horizontal ? startY : startY + i;
        if (grid[y][x] !== null && grid[y][x] !== word[i]) {
          return false;
        }
        if (grid[y][x] === word[i]) {
          hasIntersection = true;
        } else {
          // Check adjacent cells (no adjacent letters allowed unless at intersection)
          if (horizontal) {
            // Check above
            if (y > 0 && grid[y-1][x] !== null) {
              return false;
            }
            // Check below
            if (y < gridSize - 1 && grid[y+1][x] !== null) {
              return false;
            }
            // Check before word start
            if (i === 0 && x > 0 && grid[y][x-1] !== null) {
              return false;
            }
            // Check after word end
            if (i === word.length - 1 && x < gridSize - 1 && grid[y][x+1] !== null) {
              return false;
            }
          } else {
            // Check left
            if (x > 0 && grid[y][x-1] !== null) {
              return false;
            }
            // Check right
            if (x < gridSize - 1 && grid[y][x+1] !== null) {
              return false;
            }
            // Check before word start
            if (i === 0 && y > 0 && grid[y-1][x] !== null) {
              return false;
            }
            // Check after word end
            if (i === word.length - 1 && y < gridSize - 1 && grid[y+1][x] !== null) {
              return false;
            }
          }
        }
      }
      // Word must have at least one intersection with existing words
      return hasIntersection || (startX === Math.floor((gridSize - word.length) / 2)
             && startY === Math.floor(gridSize / 2));
    }

    function placeWordOnGrid(grid, word, startX, startY, horizontal) {
      for (let i = 0; i < word.length; i++) {
        if (horizontal) {
          grid[startY][startX + i] = word[i];
        } else {
          grid[startY + i][startX] = word[i];
        }
      }
    }

    function trimGrid(grid) {
      const size = grid.length;
      let minX = size, maxX = 0, minY = size, maxY = 0;
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (grid[y][x] !== null) {
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
          }
        }
      }
      minX = Math.max(0, minX - 1);
      minY = Math.max(0, minY - 1);
      maxX = Math.min(size - 1, maxX + 1);
      maxY = Math.min(size - 1, maxY + 1);
      const newWidth = maxX - minX + 1;
      const newHeight = maxY - minY + 1;
      const trimmedGrid = [];
      for (let y = 0; y < newHeight; y++) {
        trimmedGrid[y] = [];
        for (let x = 0; x < newWidth; x++) {
          trimmedGrid[y][x] = grid[y + minY][x + minX];
        }
      }
      return {
        grid: trimmedGrid,
        trimFromLeft: minX,
        trimFromTop: minY
      };
    }

    function numberGrid(grid, placedWords) {
      const height = grid.length;
      const width = grid[0].length;
      let currentNumber = 1;
      for (let pw of placedWords) {
        delete pw.number;
      }
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          if (grid[y][x] !== null) {
            let numberH = false;
            let numberV = false;
            if ((x === 0 || grid[y][x-1] === null)
                && (x < width - 1 && grid[y][x+1] !== null)) {
              numberH = true;
            }
            if ((y === 0 || grid[y-1][x] === null)
                && (y < height - 1 && grid[y+1][x] !== null)) {
              numberV = true;
            }
            if (numberH || numberV) {
              // Assign the number to matching words
              if (numberH) {
                for (let pw of placedWords) {
                  if (pw.horizontal && pw.startX === x && pw.startY === y) {
                    pw.number = currentNumber;
                  }
                }
              }
              if (numberV) {
                for (let pw of placedWords) {
                  if (!pw.horizontal && pw.startX === x && pw.startY === y) {
                    pw.number = currentNumber;
                  }
                }
              }
              currentNumber++;
            }
          }
        }
      }
      // If any words have no number, assign one
      for (let pw of placedWords) {
        if (pw.number === undefined) {
          pw.number = currentNumber++;
        }
      }
    }

    function renderCrossword(puzzle, showAnswers) {
      const grid = puzzle.grid;
      const height = grid.length;
      const width = grid[0].length;
      
      // Cell size
      const maxDim = Math.max(width, height);
      let cellSize = '25px';
      if (maxDim > 15) { cellSize = '22px'; }
      else if (maxDim > 12) { cellSize = '24px'; }

      let html = `<div class="crossword-grid-container">
                    <table class="crossword-grid" style="--cell-size: ${cellSize};">`;
      for (let y = 0; y < height; y++) {
        html += '<tr>';
        for (let x = 0; x < width; x++) {
          if (grid[y][x] === null) {
            html += '<td></td>';
          } else {
            let cellNumber = '';
            if (isStartOfWord(grid, x, y)) {
              const n = getWordNumber(puzzle.placedWords, x, y);
              if (n) {
                cellNumber = `<span class="cell-number">${n}</span>`;
              }
            }
            const cellContent = showAnswers ? grid[y][x] : '';
            html += `<td class="crossword-cell">${cellNumber}${cellContent}</td>`;
          }
        }
        html += '</tr>';
      }
      html += '</table></div>';
      
      // Clues
      html += '<div class="clues-container">';
      if (puzzle.acrossClues.length > 0) {
        html += '<div class="across-clues">';
        html += '<div class="worksheet-heading">Across:</div>';
        html += '<ol class="clue-list">';
        for (let clue of puzzle.acrossClues) {
          html += `<li class="clue-item"><strong>${clue.number}.</strong> ${clue.clue}</li>`;
        }
        html += '</ol></div>';
      }
      if (puzzle.downClues.length > 0) {
        html += '<div class="down-clues">';
        html += '<div class="worksheet-heading">Down:</div>';
        html += '<ol class="clue-list">';
        for (let clue of puzzle.downClues) {
          html += `<li class="clue-item"><strong>${clue.number}.</strong> ${clue.clue}</li>`;
        }
        html += '</ol></div>';
      }
      html += '</div>';

      // Update both the preview and PDF export containers
      if (showAnswers) {
        document.getElementById('answerKeyContainer').innerHTML = html;
        
        // For PDF export - full unscaled version
        document.getElementById('pdfAnswerKeyContainer').innerHTML = 
          `<div class="preview-content">
            <div class="pdf-export-wrapper">
              <h3 class="preview-title">${document.getElementById('puzzleTitle').value || "Crossword Puzzle"}</h3>
              ${html}
            </div>
          </div>`;
      } else {
        document.getElementById('crosswordContainer').innerHTML = html;
        
        // For PDF export - full unscaled version
        document.getElementById('pdfWorksheetContainer').innerHTML = 
          `<div class="preview-content">
            <div class="pdf-export-wrapper">
              <h3 class="preview-title">${document.getElementById('puzzleTitle').value || "Crossword Puzzle"}</h3>
              ${html}
            </div>
          </div>`;
      }
      
      updatePreviewScale(); // <-- scale preview each time
    }

    function isStartOfWord(grid, x, y) {
      if (grid[y][x] === null) return false;
      const height = grid.length;
      const width = grid[0].length;
      const horizStart = ((x === 0 || grid[y][x-1] === null)
                          && (x < width - 1 && grid[y][x+1] !== null));
      const vertStart = ((y === 0 || grid[y-1][x] === null)
                          && (y < height - 1 && grid[y+1][x] !== null));
      return horizStart || vertStart;
    }

    function getWordNumber(placedWords, x, y) {
      for (let pw of placedWords) {
        if (pw.startX === x && pw.startY === y) {
          return pw.number;
        }
      }
      return null;
    }

    // PDF export
    function printPuzzle() {
      if (!generatedPuzzle) {
        showNotification("Generate a puzzle first");
        return;
      }
      
      const puzzleTitle = (document.getElementById('puzzleTitle').value || "Crossword_Puzzle")
                          .replace(/\s+/g, '_');
      const filename = puzzleTitle + '.pdf';
      
      // Use the unscaled version for PDF export
      const content = document.getElementById('pdfWorksheetContainer');
      content.classList.add('active'); // Make it visible for html2pdf
      
      // Ensure all content is visible
      const cluesContainer = content.querySelector('.clues-container');
      if (cluesContainer) {
        cluesContainer.style.display = 'block';
        cluesContainer.style.visibility = 'visible';
        cluesContainer.style.height = 'auto';
      }
      
      const options = {
        margin: [10, 10, 10, 10],
        filename: filename,
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: {
          scale: 2,
          useCORS: true,
          scrollY: 0,
          windowHeight: 2000, // Ensure there's enough height to capture everything
          onclone: function(doc) {
            // Force visibility of clues in PDF
            const cluesContainer = doc.querySelector('.pdf-export-container .clues-container');
            if (cluesContainer) {
              cluesContainer.style.display = 'block';
              cluesContainer.style.visibility = 'visible';
              cluesContainer.style.position = 'static';
              cluesContainer.style.overflow = 'visible';
              cluesContainer.style.height = 'auto';
            }
          }
        },
        jsPDF: {
          unit: 'mm',
          format: 'a4',
          orientation: 'portrait',
          compress: true
        },
        pagebreak: { mode: ['avoid', 'css', 'legacy'], avoid: '.pdf-export-wrapper' }
      };
      
      showLoading(true);
      
      // Add a slight delay to ensure DOM is fully rendered
      setTimeout(() => {
        html2pdf()
          .set(options)
          .from(content)
          .save()
          .then(() => {
            content.classList.remove('active');
            showLoading(false);
            showNotification("Worksheet downloaded successfully");
          })
          .catch(err => {
            content.classList.remove('active');
            showLoading(false);
            console.error("PDF generation error:", err);
            showNotification("Error downloading PDF. Try again.");
          });
      }, 100);
    }

    function printAnswerKey() {
      if (!generatedPuzzle) {
        showNotification("Generate a puzzle first");
        return;
      }
      
      const puzzleTitle = (document.getElementById('puzzleTitle').value || "Crossword_Puzzle")
                          .replace(/\s+/g, '_');
      const filename = puzzleTitle + '_Answer_Key.pdf';
      
      // Use the unscaled version for PDF export
      const content = document.getElementById('pdfAnswerKeyContainer');
      content.classList.add('active'); // Make it visible for html2pdf
      
      // Ensure all content is visible
      const cluesContainer = content.querySelector('.clues-container');
      if (cluesContainer) {
        cluesContainer.style.display = 'block';
        cluesContainer.style.visibility = 'visible';
        cluesContainer.style.height = 'auto';
      }
      
      const options = {
        margin: [10, 10, 10, 10],
        filename: filename,
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: {
          scale: 2,
          useCORS: true,
          scrollY: 0,
          windowHeight: 2000, // Ensure there's enough height to capture everything
          onclone: function(doc) {
            // Force visibility of clues in PDF
            const cluesContainer = doc.querySelector('.pdf-export-container .clues-container');
            if (cluesContainer) {
              cluesContainer.style.display = 'block';
              cluesContainer.style.visibility = 'visible';
              cluesContainer.style.position = 'static';
              cluesContainer.style.overflow = 'visible';
              cluesContainer.style.height = 'auto';
            }
          }
        },
        jsPDF: {
          unit: 'mm',
          format: 'a4',
          orientation: 'portrait',
          compress: true
        },
        pagebreak: { mode: ['avoid', 'css', 'legacy'], avoid: '.pdf-export-wrapper' }
      };
      
      showLoading(true);
      
      // Add a slight delay to ensure DOM is fully rendered
      setTimeout(() => {
        html2pdf()
          .set(options)
          .from(content)
          .save()
          .then(() => {
            content.classList.remove('active');
            showLoading(false);
            showNotification("Answer key downloaded successfully");
          })
          .catch(err => {
            content.classList.remove('active');
            showLoading(false);
            console.error("PDF generation error:", err);
            showNotification("Error downloading PDF. Try again.");
          });
      }, 100);
    }
  </script>
</body>
</html>
