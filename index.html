<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Crossword Puzzle Generator</title>
  <style>
    :root {
      --primary-color: #00BCD4;
      --secondary-color: #007A87;
      --light-gray: #f3f3f3;
      --dark-gray: #333;
      --border-color: #ddd;
    }
    * {
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    body {
      margin: 0;
      padding: 0;
      background-color: #fff;
      color: #333;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
    }
    header {
      padding: 20px 0;
      border-bottom: 1px solid var(--border-color);
    }
    h1 {
      color: var(--primary-color);
      margin: 0;
      font-size: 2.2rem;
    }
    h2 {
      color: #444;
      font-weight: normal;
      margin: 0;
    }
    .content {
      display: flex;
      margin-top: 30px;
      gap: 40px;
    }
    .input-section {
      flex: 1;
    }
    .preview-section {
      flex: 1;
      background-color: white;
      padding: 20px;
      border-radius: 4px;
      position: relative;
    }
    .section-title {
      font-size: 1.5rem;
      margin-bottom: 10px;
    }
    .help-text {
      margin-bottom: 20px;
      color: #666;
      font-size: 14px;
    }
    .title-input {
      width: 100%;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      margin-bottom: 20px;
      font-size: 16px;
    }
    .word-input {
      width: 100%;
      height: 300px;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      resize: vertical;
      font-size: 14px;
      font-family: monospace;
    }
    .create-btn {
      background-color: var(--secondary-color);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 10px 25px;
      cursor: pointer;
      font-size: 16px;
      margin-top: 20px;
      float: right;
    }
    .create-btn:hover {
      background-color: #005F6B;
    }
    .preview-tabs {
      display: flex;
      margin-bottom: 20px;
    }
    .preview-tab {
      padding: 8px 20px;
      cursor: pointer;
      background-color: #e0e0e0;
      border: none;
      margin-right: 5px;
      font-weight: bold;
      font-size: 14px;
      border-radius: 3px 3px 0 0;
    }
    .preview-tab.active {
      background-color: #fff;
    }
    .preview-content {
      background-color: white;
      border-radius: 4px;
      padding: 20px;
      text-align: center;
    }
    .preview-title {
      margin-bottom: 25px;
      font-size: 20px;
      font-weight: bold;
    }
    .download-section {
      margin-top: 20px;
    }
    .download-btn {
      background-color: var(--secondary-color);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 10px 15px;
      cursor: pointer;
      margin: 5px;
      display: block;
      width: 100%;
      text-align: center;
      font-size: 14px;
    }
    .download-btn:hover {
      background-color: #005F6B;
    }
    .scramble-btn {
      background-color: #f1f1f1;
      border: 1px solid #ddd;
      color: #666;
      border-radius: 50px;
      padding: 8px 15px;
      margin-bottom: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }
    .scramble-btn svg {
      margin-right: 5px;
    }
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: var(--primary-color);
      color: white;
      padding: 15px 20px;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      transform: translateX(200%);
      transition: transform 0.3s ease-in-out;
      z-index: 1000;
    }
    .notification.show {
      transform: translateX(0);
    }
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      display: none;
    }
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s ease-in-out infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* ---------- "Page preview" container, sized like A4 ---------- */
    .page-preview {
      /* Approx. A4 at 96 dpi: 794px x 1123px */
      width: 794px;
      height: 1123px;
      border: 1px solid #ccc;
      margin: 0 auto;
      position: relative;
      overflow: hidden;
      box-shadow: 0 0 4px rgba(0,0,0,0.2);
    }
    /* Wrapper we can scale if puzzle is too large */
    .page-scale-wrapper {
      transform-origin: top left;
      position: absolute;
      left: 0;
      top: 0;
      width: auto;
      height: auto;
    }
    
    /* For PDF export - we'll hide this normally */
    .pdf-export-container {
      position: fixed;
      left: -9999px;
      top: -9999px;
      visibility: hidden;
    }
    .pdf-export-container.active {
      position: static;
      visibility: visible;
    }
    /* Make sure everything stays together in the PDF */
    .pdf-export-wrapper {
      page-break-inside: avoid !important;
      break-inside: avoid !important;
    }

    /* CROSSWORD LAYOUT */
    .crossword-grid-container {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }
    .crossword-grid {
      border-collapse: collapse;
      margin: 0 auto;
      margin-bottom: 20px;
      border: 2px solid white;
    }
    .crossword-grid td {
      padding: 0;
    }
    .crossword-cell {
      width: var(--cell-size, 25px);
      height: var(--cell-size, 25px);
      border: 1px solid #333;
      text-align: center;
      font-size: 16px;
      position: relative;
      background-color: white;
    }
    .cell-number {
      position: absolute;
      top: 1px;
      left: 2px;
      font-size: 9px;
      font-weight: normal;
    }
    .worksheet-heading {
      margin: 0 0 15px 0;
      text-align: left;
      font-weight: bold;
      font-size: 16px;
    }
    .clues-container {
      margin-top: 30px;
      display: flex;
      flex-wrap: wrap;
      gap: 40px;
      text-align: left;
      justify-content: center;
    }
    .across-clues, .down-clues {
      flex: 1;
      min-width: 250px;
    }
    .clue-list {
      list-style-type: none;
      padding-left: 0;
    }
    .clue-item {
      margin-bottom: 8px;
      font-size: 14px;
      line-height: 1.4;
    }

    /* PRINT STYLES */
    @media print {
      @page {
        size: A4;
        margin: 10mm;
      }
      body, html {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        font-size: 10pt;
      }
      .container, .input-section, .tabs, .scramble-btn, header,
      .create-btn, .preview-tabs, .download-section, .page-preview {
        display: none !important;
      }
      .preview-section {
        width: 100% !important;
        background: none;
        padding: 0;
        margin: 0;
        box-shadow: none;
      }
      .pdf-export-container {
        position: static !important;
        visibility: visible !important;
        transform: none !important;
        width: 100% !important;
        height: auto !important;
      }
      .pdf-export-container .crossword-grid-container {
        margin-bottom: 5mm;
      }
      .pdf-export-container .crossword-cell {
        width: 7mm;
        height: 7mm;
        border: 0.5pt solid black !important;
        font-size: 12pt;
      }
      .pdf-export-container .cell-number {
        font-size: 6pt;
      }
      .pdf-export-container .clues-container {
        display: block !important;
        column-count: 2;
        column-gap: 5mm;
        width: 100%;
        margin-top: 5mm !important;
        page-break-before: avoid !important;
        page-break-inside: avoid !important;
        break-inside: avoid !important;
      }
      
      .pdf-export-container .across-clues,
      .pdf-export-container .down-clues {
        display: block !important;
        break-inside: avoid !important;
        page-break-inside: avoid !important;
      }
      .pdf-export-container .worksheet-heading {
        font-size: 12pt;
        margin-bottom: 4mm;
      }
      .pdf-export-container .preview-title {
        font-size: 16pt;
        margin-bottom: 8mm;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Crossword Puzzle</h1>
      <h2>Reading worksheet generator</h2>
    </header>
    <div class="content">
      <div class="input-section">
        <h3 class="section-title">Enter crossword puzzle content</h3>
        <p class="help-text">See instructions below. Under 16 words is best for a single page.</p>
        
        <div>
          <label for="puzzleTitle">Title</label>
          <input type="text" id="puzzleTitle" class="title-input" value="Crossword Puzzle">
        </div>
        
        <div>
          <label for="wordsList">Words</label>
          <textarea id="wordsList" class="word-input"
            placeholder="Type or paste your list of words here"></textarea>
        </div>
        
        <button class="create-btn" onclick="generateCrossword()">Create</button>
      </div>

      <div class="preview-section">
        <h3 class="section-title">Preview Worksheet</h3>
        <div class="preview-tabs">
          <button class="preview-tab active" onclick="showPreviewTab('worksheet')">WORKSHEET</button>
          <button class="preview-tab" onclick="showPreviewTab('answerKey')">ANSWER KEY</button>
        </div>
        
        <!-- The "page preview" that mimics A4 size -->
        <div class="page-preview">
          <!-- We'll scale the puzzle inside here if it's too large -->
          <div class="page-scale-wrapper" id="pageScaleWrapper">
            <div id="previewContent" class="preview-content">
              <div id="worksheetPreview">
                <h3 class="preview-title" id="previewTitle">Crossword Puzzle</h3>
                <div id="crosswordContainer">
                  <p>Your puzzle will appear here after you create it.</p>
                </div>
              </div>
              <div id="answerKeyPreview" style="display: none;">
                <h3 class="preview-title" id="answerKeyTitle">Crossword Puzzle</h3>
                <div id="answerKeyContainer">
                  <p>Your answer key will appear here after you create it.</p>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <button class="scramble-btn">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"
               viewBox="0 0 24 24" fill="none" stroke="currentColor"
               stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4
                     A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4
                     A2 2 0 0 0 21 16z"></path>
            <path d="M12 22.5v-5.5m0 0l12-7m-24 0l12 7"></path>
          </svg>
          Scramble
        </button>
        
        <div class="download-section">
          <button class="download-btn" onclick="printPuzzle()">Download Worksheet</button>
          <button class="download-btn" onclick="printAnswerKey()">Download Answer Key</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Hidden containers for PDF export (no scaling applied) -->
  <div id="pdfWorksheetContainer" class="pdf-export-container"></div>
  <div id="pdfAnswerKeyContainer" class="pdf-export-container"></div>

  <div class="notification" id="notification">Notification message</div>
  <div class="loading-overlay" id="loadingOverlay">
    <div class="spinner"></div>
  </div>

  <!-- html2pdf -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script>
    // Global variables
    let generatedPuzzle = null;
    let currentPreviewTab = 'worksheet';
    
    // Example placeholder
    window.onload = function() {
      const wordsList = document.getElementById('wordsList');
      if (!wordsList.value) {
        wordsList.placeholder = 
`fire, flames that burn and can cause damage
fire fighter, a person whose job is to put out fires
smoke, the gray or black cloud that comes from a fire
burn, an injury caused by fire or heat
to save, to stop something from being damaged or destroyed
to rescue, to save someone from danger
to survive, to continue to live after a dangerous situation`;
      }
    };

    function showPreviewTab(tabName) {
      currentPreviewTab = tabName;
      const previewTabs = document.getElementsByClassName("preview-tab");
      for (let i = 0; i < previewTabs.length; i++) {
        previewTabs[i].classList.remove("active");
      }
      document.querySelector(`.preview-tab[onclick="showPreviewTab('${tabName}')"]`)
              .classList.add("active");

      // Show/hide the correct preview
      if (tabName === 'worksheet') {
        document.getElementById('worksheetPreview').style.display = 'block';
        document.getElementById('answerKeyPreview').style.display = 'none';
      } else {
        document.getElementById('worksheetPreview').style.display = 'none';
        document.getElementById('answerKeyPreview').style.display = 'block';
      }
      updatePreviewScale();
    }
    
    function showNotification(message) {
      const notification = document.getElementById("notification");
      notification.textContent = message;
      notification.classList.add("show");
      setTimeout(() => {
        notification.classList.remove("show");
      }, 3000);
    }
    
    function showLoading(show) {
      document.getElementById("loadingOverlay").style.display = show ? "flex" : "none";
    }
    
    // Scale the puzzle to fit within .page-preview
    function updatePreviewScale() {
      const previewWrapper = document.querySelector('.page-preview');
      const scaleWrapper = document.getElementById('pageScaleWrapper');
      // reset scale so we measure "actual" size
      scaleWrapper.style.transform = 'scale(1)';

      const maxW = previewWrapper.clientWidth;
      const maxH = previewWrapper.clientHeight;
      const contentW = scaleWrapper.scrollWidth;
      const contentH = scaleWrapper.scrollHeight;

      let scale = 1;
      if (contentW && contentH) {
        const scaleW = maxW / contentW;
        const scaleH = maxH / contentH;
        scale = Math.min(scaleW, scaleH, 1);
      }
      scaleWrapper.style.transform = `scale(${scale})`;
    }

    // Parse user input
    function parseWordsInput() {
      const wordsText = document.getElementById('wordsList').value.trim();
      const lines = wordsText.split('\n');
      const words = [];
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;

        const firstCommaIndex = line.indexOf(',');
        if (firstCommaIndex === -1) {
          showNotification("Line " + (i + 1) + " is missing a definition. Format: term, definition");
          return null;
        }

        const term = line.substring(0, firstCommaIndex).trim().toUpperCase();
        const definition = line.substring(firstCommaIndex + 1).trim();
        const cleanTerm = term.replace(/[^A-Z]/g, "");
        if (cleanTerm.length < 2) {
          showNotification("Term '" + term + "' is too short (2+ letters).");
          return null;
        }
        words.push({ word: cleanTerm, clue: definition });
      }
      if (words.length < 3) {
        showNotification("Please enter at least 3 terms with definitions");
        return null;
      }
      if (words.length > 16) {
        showNotification("Too many terms. Please limit to 16 for best layout.");
        return null;
      }
      return words;
    }

    // Generate puzzle
    function generateCrossword() {
      showLoading(true);
      setTimeout(() => {
        try {
          const words = parseWordsInput();
          if (!words) {
            showLoading(false);
            return;
          }
          const puzzleTitle = document.getElementById('puzzleTitle').value || "Crossword Puzzle";
          document.getElementById('previewTitle').textContent = puzzleTitle;
          document.getElementById('answerKeyTitle').textContent = puzzleTitle;

          try {
            generatedPuzzle = createCrosswordGrid(words);
            renderCrossword(generatedPuzzle, false); // Worksheet
            renderCrossword(generatedPuzzle, true);  // Answer Key
            showPreviewTab('worksheet');
          } catch (err) {
            console.error(err);
            showNotification("Error generating crossword. Try different terms.");
          }
        } catch (err) {
          console.error(err);
          showNotification("Error processing input. Check format.");
        } finally {
          showLoading(false);
        }
      }, 100);
    }

    function createCrosswordGrid(words) {
      // Sort words by length descending
      words.sort((a, b) => b.word.length - a.word.length);
      const gridSize = calculateGridSize(words);
      const grid = createEmptyGrid(gridSize);
      const placedWords = [];

      // Place first word in the middle horizontally
      const firstWord = words[0];
      const startX = Math.floor((gridSize - firstWord.word.length) / 2);
      const startY = Math.floor(gridSize / 2);
      placeWordOnGrid(grid, firstWord.word, startX, startY, true);
      placedWords.push({
        word: firstWord.word,
        clue: firstWord.clue,
        startX: startX,
        startY: startY,
        horizontal: true
      });

      // Attempt to place remaining
      for (let i = 1; i < words.length; i++) {
        const currentWord = words[i];
        let placed = false;

        for (let j = 0; j < placedWords.length && !placed; j++) {
          const placedWord = placedWords[j];
          // horizontal intersection
          if (!placedWord.horizontal) {
            for (let charIndex = 0; charIndex < currentWord.word.length && !placed; charIndex++) {
              for (let pc = 0; pc < placedWord.word.length && !placed; pc++) {
                if (currentWord.word[charIndex] === placedWord.word[pc]) {
                  const newX = placedWord.startX - charIndex;
                  const newY = placedWord.startY + pc;
                  if (canPlaceWord(grid, currentWord.word, newX, newY, true)) {
                    placeWordOnGrid(grid, currentWord.word, newX, newY, true);
                    placedWords.push({
                      word: currentWord.word,
                      clue: currentWord.clue,
                      startX: newX,
                      startY: newY,
                      horizontal: true
                    });
                    placed = true;
                  }
                }
              }
            }
          }
          // vertical intersection
          if (placedWord.horizontal && !placed) {
            for (let charIndex = 0; charIndex < currentWord.word.length && !placed; charIndex++) {
              for (let pc = 0; pc < placedWord.word.length && !placed; pc++) {
                if (currentWord.word[charIndex] === placedWord.word[pc]) {
                  const newX = placedWord.startX + pc;
                  const newY = placedWord.startY - charIndex;
                  if (canPlaceWord(grid, currentWord.word, newX, newY, false)) {
                    placeWordOnGrid(grid, currentWord.word, newX, newY, false);
                    placedWords.push({
                      word: currentWord.word,
                      clue: currentWord.clue,
                      startX: newX,
                      startY: newY,
                      horizontal: false
                    });
                    placed = true;
                  }
                }
              }
            }
          }
        }
      }
      // Trim
      const trimmed = trimGrid(grid);
      const adjustX = trimmed.trimFromLeft;
      const adjustY = trimmed.trimFromTop;
      for (let pw of placedWords) {
        pw.startX -= adjustX;
        pw.startY -= adjustY;
      }
      numberGrid(trimmed.grid, placedWords);

      const acrossClues = [];
      const downClues = [];
      for (let w of placedWords) {
        if (w.horizontal) {
          acrossClues.push({ number: w.number, clue: w.clue, word: w.word });
        } else {
          downClues.push({ number: w.number, clue: w.clue, word: w.word });
        }
      }
      acrossClues.sort((a, b) => a.number - b.number);
      downClues.sort((a, b) => a.number - b.number);

      return {
        grid: trimmed.grid,
        placedWords: placedWords,
        acrossClues,
        downClues
      };
    }

    function calculateGridSize(words) {
      let maxLength = 0;
      for (let w of words) {
        maxLength = Math.max(maxLength, w.word.length);
      }
      // some padding
      return Math.max(20, maxLength + 10);
    }

    function createEmptyGrid(size) {
      const g = [];
      for (let y = 0; y < size; y++) {
        g[y] = [];
        for (let x = 0; x < size; x++) {
          g[y][x] = null;
        }
      }
      return g;
    }

    function canPlaceWord(grid, word, startX, startY, horizontal) {
      const gridSize = grid.length;
      if (horizontal) {
        if (startX < 0 || startX + word.length > gridSize || startY < 0 || startY >= gridSize) {
          return false;
        }
      } else {
        if (startX < 0 || startX >= gridSize || startY < 0 || startY + word.length > gridSize) {
          return false;
        }
      }
      let hasIntersection = false;
      for (let i = 0; i < word.length; i++) {
        const x = horizontal ? startX + i : startX;
        const y = horizontal ? startY : startY + i;
        if (grid[y][x] !== null && grid[y][x] !== word[i]) {
          return false;
        }
        if (grid[y][x] === word[i]) {
          hasIntersection = true;
        }
      }
      // must intersect or be first word
      return hasIntersection || (startX === Math.floor((gridSize - word.length) / 2)
             && startY === Math.floor(gridSize / 2));
    }

    function placeWordOnGrid(grid, word, startX, startY, horizontal) {
      for (let i = 0; i < word.length; i++) {
        if (horizontal) {
          grid[startY][startX + i] = word[i];
        } else {
          grid[startY + i][startX] = word[i];
        }
      }
    }

    function trimGrid(grid) {
      const size = grid.length;
      let minX = size, maxX = 0, minY = size, maxY = 0;
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (grid[y][x] !== null) {
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
          }
        }
      }
      minX = Math.max(0, minX - 1);
      minY = Math.max(0, minY - 1);
      maxX = Math.min(size - 1, maxX + 1);
      maxY = Math.min(size - 1, maxY + 1);
      const newWidth = maxX - minX + 1;
      const newHeight = maxY - minY + 1;
      const trimmedGrid = [];
      for (let y = 0; y < newHeight; y++) {
        trimmedGrid[y] = [];
        for (let x = 0; x < newWidth; x++) {
          trimmedGrid[y][x] = grid[y + minY][x + minX];
        }
      }
      return {
        grid: trimmedGrid,
        trimFromLeft: minX,
        trimFromTop: minY
      };
    }

    function numberGrid(grid, placedWords) {
      const height = grid.length;
      const width = grid[0].length;
      let currentNumber = 1;
      for (let pw of placedWords) {
        delete pw.number;
      }
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          if (grid[y][x] !== null) {
            let numberH = false;
            let numberV = false;
            if ((x === 0 || grid[y][x-1] === null)
                && (x < width - 1 && grid[y][x+1] !== null)) {
              numberH = true;
            }
            if ((y === 0 || grid[y-1][x] === null)
                && (y < height - 1 && grid[y+1][x] !== null)) {
              numberV = true;
            }
            if (numberH || numberV) {
              // Assign the number to matching words
              if (numberH) {
                for (let pw of placedWords) {
                  if (pw.horizontal && pw.startX === x && pw.startY === y) {
                    pw.number = currentNumber;
                  }
                }
              }
              if (numberV) {
                for (let pw of placedWords) {
                  if (!pw.horizontal && pw.startX === x && pw.startY === y) {
                    pw.number = currentNumber;
                  }
                }
              }
              currentNumber++;
            }
          }
        }
      }
      // If any words have no number, assign one
      for (let pw of placedWords) {
        if (pw.number === undefined) {
          pw.number = currentNumber++;
        }
      }
    }

    function renderCrossword(puzzle, showAnswers) {
      const grid = puzzle.grid;
      const height = grid.length;
      const width = grid[0].length;
      
      // Cell size
      const maxDim = Math.max(width, height);
      let cellSize = '25px';
      if (maxDim > 15) { cellSize = '22px'; }
      else if (maxDim > 12) { cellSize = '24px'; }

      let html = `<div class="crossword-grid-container">
                    <table class="crossword-grid" style="--cell-size: ${cellSize};">`;
      for (let y = 0; y < height; y++) {
        html += '<tr>';
        for (let x = 0; x < width; x++) {
          if (grid[y][x] === null) {
            html += '<td></td>';
          } else {
            let cellNumber = '';
            if (isStartOfWord(grid, x, y)) {
              const n = getWordNumber(puzzle.placedWords, x, y);
              if (n) {
                cellNumber = `<span class="cell-number">${n}</span>`;
              }
            }
            const cellContent = showAnswers ? grid[y][x] : '';
            html += `<td class="crossword-cell">${cellNumber}${cellContent}</td>`;
          }
        }
        html += '</tr>';
      }
      html += '</table></div>';
      
      // Clues
      html += '<div class="clues-container">';
      if (puzzle.acrossClues.length > 0) {
        html += '<div class="across-clues">';
        html += '<div class="worksheet-heading">Across:</div>';
        html += '<ol class="clue-list">';
        for (let clue of puzzle.acrossClues) {
          html += `<li class="clue-item"><strong>${clue.number}.</strong> ${clue.clue}</li>`;
        }
        html += '</ol></div>';
      }
      if (puzzle.downClues.length > 0) {
        html += '<div class="down-clues">';
        html += '<div class="worksheet-heading">Down:</div>';
        html += '<ol class="clue-list">';
        for (let clue of puzzle.downClues) {
          html += `<li class="clue-item"><strong>${clue.number}.</strong> ${clue.clue}</li>`;
        }
        html += '</ol></div>';
      }
      html += '</div>';

      // Update both the preview and PDF export containers
      if (showAnswers) {
        document.getElementById('answerKeyContainer').innerHTML = html;
        
        // For PDF export - full unscaled version
        document.getElementById('pdfAnswerKeyContainer').innerHTML = 
          `<div class="preview-content">
            <div class="pdf-export-wrapper">
              <h3 class="preview-title">${document.getElementById('puzzleTitle').value || "Crossword Puzzle"}</h3>
              ${html}
            </div>
          </div>`;
      } else {
        document.getElementById('crosswordContainer').innerHTML = html;
        
        // For PDF export - full unscaled version
        document.getElementById('pdfWorksheetContainer').innerHTML = 
          `<div class="preview-content">
            <div class="pdf-export-wrapper">
              <h3 class="preview-title">${document.getElementById('puzzleTitle').value || "Crossword Puzzle"}</h3>
              ${html}
            </div>
          </div>`;
      }
      
      updatePreviewScale(); // <-- scale preview each time
    }

    function isStartOfWord(grid, x, y) {
      if (grid[y][x] === null) return false;
      const height = grid.length;
      const width = grid[0].length;
      const horizStart = ((x === 0 || grid[y][x-1] === null)
                          && (x < width - 1 && grid[y][x+1] !== null));
      const vertStart = ((y === 0 || grid[y-1][x] === null)
                          && (y < height - 1 && grid[y+1][x] !== null));
      return horizStart || vertStart;
    }

    function getWordNumber(placedWords, x, y) {
      for (let pw of placedWords) {
        if (pw.startX === x && pw.startY === y) {
          return pw.number;
        }
      }
      return null;
    }

    // PDF export
    function printPuzzle() {
      if (!generatedPuzzle) {
        showNotification("Generate a puzzle first");
        return;
      }
      
      const puzzleTitle = (document.getElementById('puzzleTitle').value || "Crossword_Puzzle")
                          .replace(/\s+/g, '_');
      const filename = puzzleTitle + '.pdf';
      
      // Use the unscaled version for PDF export
      const content = document.getElementById('pdfWorksheetContainer');
      content.classList.add('active'); // Make it visible for html2pdf
      
      const options = {
        margin: [10, 10, 10, 10],
        filename: filename,
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: {
          scale: 2,
          useCORS: true,
          scrollY: 0,
          windowHeight: 2000, // Ensure there's enough height to capture everything
          onclone: function(doc) {
            // Force visibility of clues in PDF
            const cluesContainer = doc.querySelector('.pdf-export-container .clues-container');
            if (cluesContainer) {
              cluesContainer.style.display = 'block';
              cluesContainer.style.visibility = 'visible';
              cluesContainer.style.position = 'static';
              cluesContainer.style.overflow = 'visible';
              cluesContainer.style.height = 'auto';
            }
          }
        },
        jsPDF: {
          unit: 'mm',
          format: 'a4',
          orientation: 'portrait',
          compress: true
        },
        pagebreak: { mode: ['avoid', 'css', 'legacy'], avoid: '.pdf-export-wrapper' }
      };
      
      showLoading(true);
      
      html2pdf()
        .set(options)
        .from(content)
        .save()
        .then(() => {
          content.classList.remove('active');
          showLoading(false);
          showNotification("Worksheet downloaded successfully");
        })
        .catch(err => {
          content.classList.remove('active');
          showLoading(false);
          console.error("PDF generation error:", err);
          showNotification("Error downloading PDF. Try again.");
        });
    }

    function printAnswerKey() {
      if (!generatedPuzzle) {
        showNotification("Generate a puzzle first");
        return;
      }
      
      const puzzleTitle = (document.getElementById('puzzleTitle').value || "Crossword_Puzzle")
                          .replace(/\s+/g, '_');
      const filename = puzzleTitle + '_Answer_Key.pdf';
      
      // Use the unscaled version for PDF export
      const content = document.getElementById('pdfAnswerKeyContainer');
      content.classList.add('active'); // Make it visible for html2pdf
      
      // Ensure all content is visible
      const cluesContainer = content.querySelector('.clues-container');
      if (cluesContainer) {
        cluesContainer.style.display = 'block';
        cluesContainer.style.visibility = 'visible';
        cluesContainer.style.height = 'auto';
      }
      
      const options = {
        margin: [10, 10, 10, 10],
        filename: filename,
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: {
          scale: 2,
          useCORS: true,
          scrollY: 0,
          windowHeight: 2000, // Ensure there's enough height to capture everything
          onclone: function(doc) {
            // Force visibility of clues in PDF
            const cluesContainer = doc.querySelector('.pdf-export-container .clues-container');
            if (cluesContainer) {
              cluesContainer.style.display = 'block';
              cluesContainer.style.visibility = 'visible';
              cluesContainer.style.position = 'static';
              cluesContainer.style.overflow = 'visible';
              cluesContainer.style.height = 'auto';
            }
          }
        },
        jsPDF: {
          unit: 'mm',
          format: 'a4',
          orientation: 'portrait',
          compress: true
        },
        pagebreak: { mode: ['avoid', 'css', 'legacy'], avoid: '.pdf-export-wrapper' }
      };
      
      showLoading(true);
      
      // Add a slight delay to ensure DOM is fully rendered
      setTimeout(() => {
        html2pdf()
          .set(options)
          .from(content)
          .save()
          .then(() => {
            content.classList.remove('active');
            showLoading(false);
            showNotification("Answer key downloaded successfully");
          })
          .catch(err => {
            content.classList.remove('active');
            showLoading(false);
            console.error("PDF generation error:", err);
            showNotification("Error downloading PDF. Try again.");
          });
      }, 100);
    }
  </script>
</body>
</html>
