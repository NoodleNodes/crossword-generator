<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Crossword Puzzle Generator</title>

  <style>
    :root {
      --primary-color: #00BCD4;
      --secondary-color: #007A87;
      --light-gray: #f3f3f3;
      --dark-gray: #333;
      --border-color: #ddd;
    }
    * {
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    body {
      margin: 0;
      padding: 0;
      background-color: #fff;
      color: #333;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
    }
    header {
      padding: 20px 0;
      border-bottom: 1px solid var(--border-color);
    }
    h1 {
      color: var(--primary-color);
      margin: 0;
      font-size: 2.2rem;
    }
    h2 {
      color: #444;
      font-weight: normal;
      margin: 0;
    }
    .content {
      display: flex;
      margin-top: 30px;
      gap: 40px;
    }
    .input-section {
      flex: 1;
    }
    .preview-section {
      flex: 1;
      background-color: white;
      padding: 20px;
      border-radius: 4px;
      position: relative;
    }
    .section-title {
      font-size: 1.5rem;
      margin-bottom: 10px;
    }
    .help-text {
      margin-bottom: 20px;
      color: #666;
      font-size: 14px;
    }
    .title-input {
      width: 100%;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      margin-bottom: 20px;
      font-size: 16px;
    }
    .word-input {
      width: 100%;
      height: 300px;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      resize: vertical;
      font-size: 14px;
      font-family: monospace;
    }
    .create-btn {
      background-color: var(--secondary-color);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 10px 25px;
      cursor: pointer;
      font-size: 16px;
      margin-top: 20px;
      float: right;
    }
    .create-btn:hover {
      background-color: #005F6B;
    }
    .preview-tabs {
      display: flex;
      margin-bottom: 20px;
    }
    .preview-tab {
      padding: 8px 20px;
      cursor: pointer;
      background-color: #e0e0e0;
      border: none;
      margin-right: 5px;
      font-weight: bold;
      font-size: 14px;
      border-radius: 3px 3px 0 0;
    }
    .preview-tab.active {
      background-color: #fff;
    }
    .preview-content {
      background-color: white;
      border-radius: 4px;
      padding: 20px;
      text-align: center;
    }
    .preview-title {
      margin-bottom: 25px;
      font-size: 20px;
      font-weight: bold;
    }
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: var(--primary-color);
      color: white;
      padding: 15px 20px;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      transform: translateX(200%);
      transition: transform 0.3s ease-in-out;
      z-index: 1000;
    }
    .notification.show {
      transform: translateX(0);
    }
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      display: none;
    }
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s ease-in-out infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* CROSSWORD LAYOUT */
    .crossword-grid-container {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }
    .crossword-grid {
      border-collapse: collapse;
      margin: 0 auto;
      margin-bottom: 20px;
      border: 2px solid white;
    }
    .crossword-grid td {
      padding: 0;
    }
    .crossword-cell {
      width: var(--cell-size, 25px);
      height: var(--cell-size, 25px);
      border: 1px solid #333;
      text-align: center;
      font-size: 16px;
      position: relative;
      background-color: white;
    }
    .cell-number {
      position: absolute;
      top: 1px;
      left: 2px;
      font-size: 9px;
      font-weight: normal;
    }
    .worksheet-heading {
      margin: 0 0 15px 0;
      text-align: left;
      font-weight: bold;
      font-size: 16px;
    }
    .clues-container {
      margin-top: 30px;
      display: flex;
      flex-wrap: wrap;
      gap: 40px;
      text-align: left;
      justify-content: center;
    }
    .across-clues, .down-clues {
      flex: 1;
      min-width: 250px;
    }
    .clue-list {
      list-style-type: none;
      padding-left: 0;
    }
    .clue-item {
      margin-bottom: 8px;
      font-size: 14px;
      line-height: 1.4;
    }

    /* PRINT STYLES:
       Hide everything but #worksheetPreview or #answerKeyPreview 
       (whichever is displayed at print time) */
    @media print {
      @page {
        size: A4;
        margin: 10mm;
      }
      body, html {
        margin: 0;
        padding: 0;
        font-size: 10pt;
      }
      /* Hide main layout, input, etc. */
      .container, .input-section, header, .tabs, .preview-tabs {
        display: none !important;
      }
      /* The preview-section itself can remain, but we can remove any extraneous styling if desired */
      .preview-section {
        width: 100% !important;
        background: none;
        padding: 0;
        margin: 0;
        box-shadow: none;
      }
      /* If you want a single page, no overflow, you can also do:
         .preview-section { overflow: visible } */

      /* Let the puzzle fill the page. We keep the same rules,
         but can shrink cell size if needed. For a single-page puzzle:
         .crossword-cell { width: 7mm; height: 7mm; } for example 
      */
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Crossword Puzzle</h1>
      <h2>Reading worksheet generator</h2>
    </header>

    <div class="content">
      <div class="input-section">
        <h3 class="section-title">Enter crossword puzzle content</h3>
        <p class="help-text">See instructions below. Under 16 words is best for a single page.</p>
        
        <div>
          <label for="puzzleTitle">Title</label>
          <input type="text" id="puzzleTitle" class="title-input" value="Crossword Puzzle">
        </div>
        
        <div>
          <label for="wordsList">Words</label>
          <textarea id="wordsList" class="word-input"
            placeholder="Type or paste your list of words here"></textarea>
        </div>
        
        <button class="create-btn" onclick="generateCrossword()">Create</button>
      </div>

      <div class="preview-section">
        <h3 class="section-title">Preview Worksheet</h3>
        <!-- Switch between these two views with showPreviewTab() -->
        <div class="preview-tabs">
          <button class="preview-tab active" onclick="showPreviewTab('worksheet')">WORKSHEET</button>
          <button class="preview-tab" onclick="showPreviewTab('answerKey')">ANSWER KEY</button>
        </div>
        
        <div id="previewContent" class="preview-content">
          <div id="worksheetPreview">
            <h3 class="preview-title" id="previewTitle">Crossword Puzzle</h3>
            <div id="crosswordContainer">
              <p>Your puzzle will appear here after you create it.</p>
            </div>
          </div>
          
          <div id="answerKeyPreview" style="display: none;">
            <h3 class="preview-title" id="answerKeyTitle">Crossword Puzzle</h3>
            <div id="answerKeyContainer">
              <p>Your answer key will appear here after you create it.</p>
            </div>
          </div>
        </div>

        <!-- Simple print approach (no html2pdf). We rely on "Save as PDF" in the print dialog. -->
        <button class="create-btn" style="float:none; margin-right:10px;" onclick="printWorksheet()">
          Print Worksheet
        </button>
        <button class="create-btn" style="float:none;" onclick="printAnswerKey()">
          Print Answer Key
        </button>
      </div>
    </div>
  </div>

  <div class="notification" id="notification">Notification message</div>
  <div class="loading-overlay" id="loadingOverlay">
    <div class="spinner"></div>
  </div>

  <script>
    // ======== Original puzzle logic remains ========

    let generatedPuzzle = null;
    let currentPreviewTab = 'worksheet';

    window.onload = function() {
      const wordsList = document.getElementById('wordsList');
      if (!wordsList.value) {
        wordsList.placeholder = 
`fire, flames that burn and can cause damage
fire fighter, a person whose job is to put out fires
smoke, the gray or black cloud that comes from a fire
burn, an injury caused by fire or heat
to save, to stop something from being damaged or destroyed
to rescue, to save someone from danger
to survive, to continue to live after a dangerous situation`;
      }
    };

    function showPreviewTab(tabName) {
      currentPreviewTab = tabName;
      const previewTabs = document.getElementsByClassName("preview-tab");
      for (let i = 0; i < previewTabs.length; i++) {
        previewTabs[i].classList.remove("active");
      }
      document.querySelector(`.preview-tab[onclick="showPreviewTab('${tabName}')"]`)
              .classList.add("active");
      if (tabName === 'worksheet') {
        document.getElementById('worksheetPreview').style.display = 'block';
        document.getElementById('answerKeyPreview').style.display = 'none';
      } else {
        document.getElementById('worksheetPreview').style.display = 'none';
        document.getElementById('answerKeyPreview').style.display = 'block';
      }
    }

    function showNotification(message) {
      const notification = document.getElementById("notification");
      notification.textContent = message;
      notification.classList.add("show");
      setTimeout(() => {
        notification.classList.remove("show");
      }, 3000);
    }

    function showLoading(show) {
      document.getElementById("loadingOverlay").style.display = show ? "flex" : "none";
    }

    function parseWordsInput() {
      const wordsText = document.getElementById('wordsList').value.trim();
      const lines = wordsText.split('\n');
      const words = [];
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        const firstCommaIndex = line.indexOf(',');
        if (firstCommaIndex === -1) {
          showNotification("Line " + (i + 1) + " is missing a definition. Format: term, definition");
          return null;
        }
        const term = line.substring(0, firstCommaIndex).trim().toUpperCase();
        const definition = line.substring(firstCommaIndex + 1).trim();
        const cleanTerm = term.replace(/[^A-Z]/g, "");
        if (cleanTerm.length < 2) {
          showNotification("Term '" + term + "' is too short (2+ letters).");
          return null;
        }
        words.push({ word: cleanTerm, clue: definition });
      }
      if (words.length < 3) {
        showNotification("Please enter at least 3 terms with definitions");
        return null;
      }
      if (words.length > 16) {
        showNotification("Too many terms. Please limit to 16 for best layout.");
        return null;
      }
      return words;
    }

    function generateCrossword() {
      showLoading(true);
      setTimeout(() => {
        try {
          const words = parseWordsInput();
          if (!words) {
            showLoading(false);
            return;
          }
          const puzzleTitle = document.getElementById('puzzleTitle').value || "Crossword Puzzle";
          document.getElementById('previewTitle').textContent = puzzleTitle;
          document.getElementById('answerKeyTitle').textContent = puzzleTitle;

          try {
            generatedPuzzle = createCrosswordGrid(words);
            renderCrossword(generatedPuzzle, false);
            renderCrossword(generatedPuzzle, true);
            showPreviewTab('worksheet');
          } catch (error) {
            console.error(error);
            showNotification("Error generating crossword. Try different terms.");
          }
        } catch (error) {
          console.error(error);
          showNotification("Error processing input. Check format.");
        } finally {
          showLoading(false);
        }
      }, 100);
    }

    function createCrosswordGrid(words) {
      words.sort((a, b) => b.word.length - a.word.length);
      const gridSize = calculateGridSize(words);
      const grid = createEmptyGrid(gridSize);
      const placedWords = [];

      const firstWord = words[0];
      const startX = Math.floor((gridSize - firstWord.word.length) / 2);
      const startY = Math.floor(gridSize / 2);
      placeWordOnGrid(grid, firstWord.word, startX, startY, true);
      placedWords.push({
        word: firstWord.word,
        clue: firstWord.clue,
        startX: startX,
        startY: startY,
        horizontal: true
      });

      for (let i = 1; i < words.length; i++) {
        const currentWord = words[i];
        let placed = false;
        
        for (let j = 0; j < placedWords.length && !placed; j++) {
          const placedWord = placedWords[j];
          
          // Try horizontal intersection
          if (!placedWord.horizontal) {
            for (let charIndex = 0; charIndex < currentWord.word.length && !placed; charIndex++) {
              for (let pc = 0; pc < placedWord.word.length && !placed; pc++) {
                if (currentWord.word[charIndex] === placedWord.word[pc]) {
                  const newX = placedWord.startX - charIndex;
                  const newY = placedWord.startY + pc;
                  if (canPlaceWord(grid, currentWord.word, newX, newY, true)) {
                    placeWordOnGrid(grid, currentWord.word, newX, newY, true);
                    placedWords.push({
                      word: currentWord.word,
                      clue: currentWord.clue,
                      startX: newX,
                      startY: newY,
                      horizontal: true
                    });
                    placed = true;
                  }
                }
              }
            }
          }

          // Try vertical intersection
          if (placedWord.horizontal && !placed) {
            for (let charIndex = 0; charIndex < currentWord.word.length && !placed; charIndex++) {
              for (let pc = 0; pc < placedWord.word.length && !placed; pc++) {
                if (currentWord.word[charIndex] === placedWord.word[pc]) {
                  const newX = placedWord.startX + pc;
                  const newY = placedWord.startY - charIndex;
                  if (canPlaceWord(grid, currentWord.word, newX, newY, false)) {
                    placeWordOnGrid(grid, currentWord.word, newX, newY, false);
                    placedWords.push({
                      word: currentWord.word,
                      clue: currentWord.clue,
                      startX: newX,
                      startY: newY,
                      horizontal: false
                    });
                    placed = true;
                  }
                }
              }
            }
          }
        }
      }

      const trimmedGrid = trimGrid(grid);
      const adjustX = trimmedGrid.trimFromLeft;
      const adjustY = trimmedGrid.trimFromTop;
      for (let pw of placedWords) {
        pw.startX -= adjustX;
        pw.startY -= adjustY;
      }
      numberGrid(trimmedGrid.grid, placedWords);

      const acrossClues = [];
      const downClues = [];
      for (let w of placedWords) {
        if (w.horizontal) {
          acrossClues.push({ number: w.number, clue: w.clue, word: w.word });
        } else {
          downClues.push({ number: w.number, clue: w.clue, word: w.word });
        }
      }
      acrossClues.sort((a, b) => a.number - b.number);
      downClues.sort((a, b) => a.number - b.number);

      return {
        grid: trimmedGrid.grid,
        placedWords: placedWords,
        acrossClues,
        downClues
      };
    }

    function calculateGridSize(words) {
      let maxLength = 0;
      for (let w of words) {
        maxLength = Math.max(maxLength, w.word.length);
      }
      return Math.max(20, maxLength + 10);
    }

    function createEmptyGrid(size) {
      const g = [];
      for (let y = 0; y < size; y++) {
        g[y] = [];
        for (let x = 0; x < size; x++) {
          g[y][x] = null;
        }
      }
      return g;
    }

    function canPlaceWord(grid, word, startX, startY, horizontal) {
      const gridSize = grid.length;
      if (horizontal) {
        if (startX < 0 || startX + word.length > gridSize || startY < 0 || startY >= gridSize) {
          return false;
        }
      } else {
        if (startX < 0 || startX >= gridSize || startY < 0 || startY + word.length > gridSize) {
          return false;
        }
      }
      let hasIntersection = false;
      for (let i = 0; i < word.length; i++) {
        const x = horizontal ? startX + i : startX;
        const y = horizontal ? startY : startY + i;
        if (grid[y][x] !== null && grid[y][x] !== word[i]) {
          return false;
        }
        if (grid[y][x] === word[i]) {
          hasIntersection = true;
        }
      }
      return hasIntersection || 
        (startX === Math.floor((gridSize - word.length) / 2) &&
         startY === Math.floor(gridSize / 2));
    }

    function placeWordOnGrid(grid, word, startX, startY, horizontal) {
      for (let i = 0; i < word.length; i++) {
        if (horizontal) {
          grid[startY][startX + i] = word[i];
        } else {
          grid[startY + i][startX] = word[i];
        }
      }
    }

    function trimGrid(grid) {
      const size = grid.length;
      let minX = size, maxX = 0, minY = size, maxY = 0;
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (grid[y][x] !== null) {
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
          }
        }
      }
      minX = Math.max(0, minX - 1);
      minY = Math.max(0, minY - 1);
      maxX = Math.min(size - 1, maxX + 1);
      maxY = Math.min(size - 1, maxY + 1);
      const newWidth = maxX - minX + 1;
      const newHeight = maxY - minY + 1;
      const trimmedGrid = [];
      for (let y = 0; y < newHeight; y++) {
        trimmedGrid[y] = [];
        for (let x = 0; x < newWidth; x++) {
          trimmedGrid[y][x] = grid[y + minY][x + minX];
        }
      }
      return {
        grid: trimmedGrid,
        trimFromLeft: minX,
        trimFromTop: minY
      };
    }

    function numberGrid(grid, placedWords) {
      const height = grid.length;
      const width = grid[0].length;
      let currentNumber = 1;
      for (let pw of placedWords) {
        delete pw.number;
      }
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          if (grid[y][x] !== null) {
            let numberH = false;
            let numberV = false;
            if ((x === 0 || grid[y][x-1] === null)
                && (x < width - 1 && grid[y][x+1] !== null)) {
              numberH = true;
            }
            if ((y === 0 || grid[y-1][x] === null)
                && (y < height - 1 && grid[y+1][x] !== null)) {
              numberV = true;
            }
            if (numberH || numberV) {
              if (numberH) {
                for (let pw of placedWords) {
                  if (pw.horizontal && pw.startX === x && pw.startY === y) {
                    pw.number = currentNumber;
                  }
                }
              }
              if (numberV) {
                for (let pw of placedWords) {
                  if (!pw.horizontal && pw.startX === x && pw.startY === y) {
                    pw.number = currentNumber;
                  }
                }
              }
              currentNumber++;
            }
          }
        }
      }
      // If any words have no number, assign it
      for (let pw of placedWords) {
        if (pw.number === undefined) {
          pw.number = currentNumber++;
        }
      }
    }

    function renderCrossword(puzzle, showAnswers) {
      const grid = puzzle.grid;
      const height = grid.length;
      const width = grid[0].length;
      const maxDim = Math.max(width, height);

      // Slightly smaller cells if puzzle is big
      let cellSize = '25px';
      if (maxDim > 15) { cellSize = '22px'; }
      else if (maxDim > 12) { cellSize = '24px'; }

      let html = `<div class="crossword-grid-container">
                    <table class="crossword-grid" style="--cell-size: ${cellSize};">`;
      for (let y = 0; y < height; y++) {
        html += '<tr>';
        for (let x = 0; x < width; x++) {
          if (grid[y][x] === null) {
            html += '<td></td>';
          } else {
            let cellNumber = '';
            if (isStartOfWord(grid, x, y)) {
              const n = getWordNumber(puzzle.placedWords, x, y);
              if (n) {
                cellNumber = `<span class="cell-number">${n}</span>`;
              }
            }
            const cellContent = showAnswers ? grid[y][x] : '';
            html += `<td class="crossword-cell">${cellNumber}${cellContent}</td>`;
          }
        }
        html += '</tr>';
      }
      html += '</table></div>';
      
      // Clues
      html += '<div class="clues-container">';
      if (puzzle.acrossClues.length > 0) {
        html += '<div class="across-clues">';
        html += '<div class="worksheet-heading">Across:</div>';
        html += '<ol class="clue-list">';
        for (let clue of puzzle.acrossClues) {
          html += `<li class="clue-item"><strong>${clue.number}.</strong> ${clue.clue}</li>`;
        }
        html += '</ol></div>';
      }
      if (puzzle.downClues.length > 0) {
        html += '<div class="down-clues">';
        html += '<div class="worksheet-heading">Down:</div>';
        html += '<ol class="clue-list">';
        for (let clue of puzzle.downClues) {
          html += `<li class="clue-item"><strong>${clue.number}.</strong> ${clue.clue}</li>`;
        }
        html += '</ol></div>';
      }
      html += '</div>';

      if (showAnswers) {
        document.getElementById('answerKeyContainer').innerHTML = html;
      } else {
        document.getElementById('crosswordContainer').innerHTML = html;
      }
    }

    function isStartOfWord(grid, x, y) {
      if (grid[y][x] === null) return false;
      const width = grid[0].length;
      const height = grid.length;
      const horizStart = ((x === 0 || grid[y][x-1] === null)
                        && (x < width - 1 && grid[y][x+1] !== null));
      const vertStart = ((y === 0 || grid[y-1][x] === null)
                        && (y < height - 1 && grid[y+1][x] !== null));
      return horizStart || vertStart;
    }
    function getWordNumber(placedWords, x, y) {
      for (let pw of placedWords) {
        if (pw.startX === x && pw.startY === y) {
          return pw.number;
        }
      }
      return null;
    }

    // ======== Simple Print Approach ========
    function printWorksheet() {
      // Show the worksheet tab so it's visible
      showPreviewTab('worksheet');
      // Let the browser's print dialog handle it. The user can choose "Save as PDF."
      window.print();
    }

    function printAnswerKey() {
      // Show the answer key tab
      showPreviewTab('answerKey');
      window.print();
    }
  </script>
</body>
</html>
