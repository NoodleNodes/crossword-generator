<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Crossword Puzzle Generator</title>
  <style>
    :root {
      --primary-color: #00BCD4;
      --secondary-color: #007A87;
      --light-gray: #f3f3f3;
      --dark-gray: #333;
      --border-color: #ddd;
    }
    * {
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    body {
      margin: 0;
      padding: 0;
      background-color: #fff;
      color: #333;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
    }
    header {
      padding: 20px 0;
      border-bottom: 1px solid var(--border-color);
    }
    h1 {
      color: var(--primary-color);
      margin: 0;
      font-size: 2.2rem;
    }
    .content {
      display: flex;
      margin-top: 30px;
      gap: 40px;
    }
    .input-section {
      flex: 6; /* Changed from 1 to 6 to give more space */
    }
    .preview-section {
      flex: 5; /* Changed from 1 to 5 */
      background-color: white;
      padding: 20px;
      border-radius: 4px;
      position: relative;
    }
    .section-title {
      font-size: 1.5rem;
      margin-bottom: 10px;
    }
    .help-text {
      margin-bottom: 20px;
      color: #666;
      font-size: 14px;
    }
    .title-input {
      width: 100%;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      margin-bottom: 20px;
      font-size: 16px;
    }
    .word-input {
      width: 100%;
      height: 400px; /* Increased from 350px */
      padding: 15px; /* Increased from 10px */
      border: 1px solid var(--border-color);
      border-radius: 4px;
      resize: vertical;
      font-size: 15px; /* Increased from 14px */
      font-family: monospace;
      line-height: 1.5; /* Added for better spacing */
    }
    .create-btn {
      background-color: var(--secondary-color);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 10px 25px;
      cursor: pointer;
      font-size: 16px;
      margin-top: 20px;
      float: right;
    }
    .create-btn:hover {
      background-color: #005F6B;
    }
    .preview-tabs {
      display: flex;
      margin-bottom: 20px;
    }
    .preview-tab {
      padding: 8px 20px;
      cursor: pointer;
      background-color: #e0e0e0;
      border: none;
      margin-right: 5px;
      font-weight: bold;
      font-size: 14px;
      border-radius: 3px 3px 0 0;
    }
    .preview-tab.active {
      background-color: #fff;
    }
    .preview-content {
      background-color: white;
      border-radius: 4px;
      padding: 20px;
      text-align: center;
      margin: 0 auto; /* Added to center */
    }
    .preview-title {
      margin-bottom: 25px;
      font-size: 20px;
      font-weight: bold;
    }
    .download-section {
      margin-top: 20px;
    }
    .download-btn {
      background-color: var(--secondary-color);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 10px 15px;
      cursor: pointer;
      margin: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      text-align: center;
      font-size: 14px;
    }
    .download-btn svg {
      margin-right: 5px;
    }
    .download-btn:hover {
      background-color: #005F6B;
    }
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: var(--primary-color);
      color: white;
      padding: 15px 20px;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      transform: translateX(200%);
      transition: transform 0.3s ease-in-out;
      z-index: 1000;
    }
    .notification.show {
      transform: translateX(0);
    }
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      display: none;
    }
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s ease-in-out infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* ---------- "Page preview" container, sized like A4 ---------- */
    .page-preview {
      /* Approx. A4 at 96 dpi: 794px x 1123px */
      width: 500px; /* Reduced from 794px */
      height: 708px; /* Reduced proportionally from 1123px */
      border: 1px solid #ccc;
      margin: 0 auto;
      position: relative;
      overflow: hidden;
      box-shadow: 0 0 4px rgba(0,0,0,0.2);
    }
    /* Wrapper we can scale if puzzle is too large */
    .page-scale-wrapper {
      transform-origin: top left;
      position: absolute;
      left: 0;
      top: 0;
      width: auto;
      height: auto;
    }
    
    /* For PDF export - we'll hide this normally */
    .pdf-export-container {
      position: fixed;
      left: -9999px;
      top: -9999px;
      visibility: hidden;
    }
    .pdf-export-container.active {
      position: static;
      visibility: visible;
    }
    /* Make sure everything stays together in the PDF */
    .pdf-export-wrapper {
      page-break-inside: avoid !important;
      break-inside: avoid !important;
    }

    /* CROSSWORD LAYOUT */
    .crossword-grid-container {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
      width: 100%; /* Ensure full width */
    }
    .crossword-grid {
      border-collapse: collapse;
      margin: 0 auto;
      margin-bottom: 20px;
      border: 2px solid white;
    }
    .crossword-grid td {
      padding: 0;
    }
    .crossword-cell {
      width: var(--cell-size, 25px);
      height: var(--cell-size, 25px);
      border: 1px solid #333;
      text-align: center;
      font-size: 16px;
      position: relative;
      background-color: white;
    }
    .cell-number {
      position: absolute;
      top: 1px;
      left: 2px;
      font-size: 9px;
      font-weight: normal;
    }
    .worksheet-heading {
      margin: 0 0 15px 0;
      text-align: left;
      font-weight: bold;
      font-size: 16px;
    }
    .clues-container {
      margin-top: 30px;
      display: flex;
      flex-wrap: wrap;
      gap: 40px;
      text-align: left;
      justify-content: space-between; /* Changed from center to space-between */
    }
    .across-clues, .down-clues {
      flex: 1;
      min-width: 250px;
      max-width: 45%; /* Ensures neither column gets too wide */
    }
    .clue-list {
      list-style-type: none;
      padding-left: 0;
    }
    .clue-item {
      margin-bottom: 8px;
      font-size: 14px;
      line-height: 1.4;
    }
    
    /* Footer with copyright */
    .footer {
      text-align: center;
      margin-top: 40px;
      padding: 20px 0;
      font-size: 12px;
      color: #666;
      border-top: 1px solid var(--border-color);
    }

    /* PRINT STYLES */
    @media print {
      @page {
        size: A4;
        margin: 10mm;
      }
      body, html {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        font-size: 10pt;
      }
      .container, .input-section, .tabs, header,
      .create-btn, .preview-tabs, .download-section, .page-preview, .footer {
        display: none !important;
      }
      .preview-section {
        width: 100% !important;
        background: none;
        padding: 0;
        margin: 0;
        box-shadow: none;
      }
      .pdf-export-container {
        position: static !important;
        visibility: visible !important;
      }
      .pdf-export-container .crossword-grid-container {
        display: flex !important;
        justify-content: center !important;
        margin-bottom: 5mm !important;
      }
      .pdf-export-container .crossword-cell {
        width: 7mm;
        height: 7mm;
        border: 0.5pt solid black !important;
        font-size: 12pt;
      }
      .pdf-export-container .cell-number {
        font-size: 6pt;
      }
      .pdf-export-container .clues-container {
        display: block !important;
        column-count: 2;
        column-gap: 5mm;
        width: 100%;
        margin-top: 5mm !important;
        page-break-before: avoid !important;
        page-break-inside: avoid !important;
        break-inside: avoid !important;
      }
      
      .pdf-export-container .across-clues,
      .pdf-export-container .down-clues {
        display: block !important;
        break-inside: avoid !important;
        page-break-inside: avoid !important;
      }
      .pdf-export-container .worksheet-heading {
        font-size: 12pt;
        margin-bottom: 4mm;
      }
      .pdf-export-container .preview-title {
        font-size: 16pt;
        margin-bottom: 8mm;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Crossword Puzzle Generator</h1>
    </header>
    <div class="content">
      <div class="input-section">
        <h3 class="section-title">Enter crossword puzzle content</h3>
        <p class="help-text">See instructions below. Under 20 words is best for a single page.</p>
        
        <div>
          <label for="puzzleTitle">Title</label>
          <input type="text" id="puzzleTitle" class="title-input" value="Crossword Puzzle">
        </div>
        
        <div>
          <label for="wordsList">Words</label>
          <textarea id="wordsList" class="word-input"
            placeholder="Type or paste your list of words here"></textarea>
        </div>
        
        <button class="create-btn" onclick="generateCrossword()">Create</button>
      </div>

      <div class="preview-section">
        <h3 class="section-title">Preview Worksheet</h3>
        <div class="preview-tabs">
          <button class="preview-tab active" onclick="showPreviewTab('worksheet')">WORKSHEET</button>
          <button class="preview-tab" onclick="showPreviewTab('answerKey')">ANSWER KEY</button>
        </div>
        
        <!-- The "page preview" that mimics A4 size -->
        <div class="page-preview">
          <!-- We'll scale the puzzle inside here if it's too large -->
          <div class="page-scale-wrapper" id="pageScaleWrapper">
            <div id="previewContent" class="preview-content">
              <div id="worksheetPreview">
                <h3 class="preview-title" id="previewTitle">Crossword Puzzle</h3>
                <div id="crosswordContainer">
                  <p>Your puzzle will appear here after you create it.</p>
                </div>
              </div>
              <div id="answerKeyPreview" style="display: none;">
                <h3 class="preview-title" id="answerKeyTitle">Crossword Puzzle</h3>
                <div id="answerKeyContainer">
                  <p>Your answer key will appear here after you create it.</p>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="download-section">
          <button class="download-btn" onclick="printPuzzle()">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
              <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
              <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
            </svg>
            Download Worksheet
          </button>
          
          <button class="download-btn" onclick="printAnswerKey()">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
              <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
              <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
            </svg>
            Download Answer Key
          </button>
        </div>
      </div>
    </div>
    
    <!-- Footer with copyright -->
    <div class="footer">
      made with ❤️ by Shandé
    </div>
  </div>

  <!-- Hidden containers for PDF export (no scaling applied) -->
  <div id="pdfWorksheetContainer" class="pdf-export-container"></div>
  <div id="pdfAnswerKeyContainer" class="pdf-export-container"></div>

  <div class="notification" id="notification">Notification message</div>
  <div class="loading-overlay" id="loadingOverlay">
    <div class="spinner"></div>
  </div>

  <!-- html2pdf -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script>
    // Global variables
    let generatedPuzzle = null;
    let currentPreviewTab = 'worksheet';
    
    // Example placeholder
    window.onload = function() {
      const wordsList = document.getElementById('wordsList');
      if (!wordsList.value) {
        wordsList.placeholder = 
`fire, flames that burn and can cause damage
fire fighter, a person whose job is to put out fires
smoke, the gray or black cloud that comes from a fire
burn, an injury caused by fire or heat
to save, to stop something from being damaged or destroyed
to rescue, to save someone from danger
to survive, to continue to live after a dangerous situation`;
      }
    };

    function showPreviewTab(tabName) {
      currentPreviewTab = tabName;
      const previewTabs = document.getElementsByClassName("preview-tab");
      for (let i = 0; i < previewTabs.length; i++) {
        previewTabs[i].classList.remove("active");
      }
      document.querySelector(`.preview-tab[onclick="showPreviewTab('${tabName}')"]`)
              .classList.add("active");

      // Show/hide the correct preview
      if (tabName === 'worksheet') {
        document.getElementById('worksheetPreview').style.display = 'block';
        document.getElementById('answerKeyPreview').style.display = 'none';
      } else {
        document.getElementById('worksheetPreview').style.display = 'none';
        document.getElementById('answerKeyPreview').style.display = 'block';
      }
      updatePreviewScale();
    }
    
    function showNotification(message) {
      const notification = document.getElementById("notification");
      notification.textContent = message;
      notification.classList.add("show");
      setTimeout(() => {
        notification.classList.remove("show");
      }, 3000);
    }
    
    function showLoading(show) {
      document.getElementById("loadingOverlay").style.display = show ? "flex" : "none";
    }
    
    // Scale the puzzle to fit within .page-preview
    function updatePreviewScale() {
      const previewWrapper = document.querySelector('.page-preview');
      const scaleWrapper = document.getElementById('pageScaleWrapper');
      // reset scale so we measure "actual" size
      scaleWrapper.style.transform = 'scale(1)';

      const maxW = previewWrapper.clientWidth;
      const maxH = previewWrapper.clientHeight;
      const contentW = scaleWrapper.scrollWidth;
      const contentH = scaleWrapper.scrollHeight;

      let scale = 1;
      if (contentW && contentH) {
        const scaleW = maxW / contentW;
        const scaleH = maxH / contentH;
        scale = Math.min(scaleW, scaleH, 1);
      }
      scaleWrapper.style.transform = `scale(${scale})`;
    }

    // Parse user input
    function parseWordsInput() {
      const wordsText = document.getElementById('wordsList').value.trim();
      const lines = wordsText.split('\n');
      const words = [];
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;

        const firstCommaIndex = line.indexOf(',');
        if (firstCommaIndex === -1) {
          showNotification("Line " + (i + 1) + " is missing a definition. Format: term, definition");
          return null;
        }

        const term = line.substring(0, firstCommaIndex).trim().toUpperCase();
        const definition = line.substring(firstCommaIndex + 1).trim();
        const cleanTerm = term.replace(/[^A-Z]/g, "");
        if (cleanTerm.length < 2) {
          showNotification("Term '" + term + "' is too short (2+ letters).");
          return null;
        }
        words.push({ word: cleanTerm, clue: definition });
      }
      if (words.length < 3) {
        showNotification("Please enter at least 3 terms with definitions");
        return null;
      }
      if (words.length > 20) { // Increased from 16 to 20
        showNotification("Too many terms. Please limit to 20 for best layout.");
        return null;
      }
      return words;
    }

    // Generate puzzle
    function generateCrossword() {
      showLoading(true);
      setTimeout(() => {
        try {
          const words = parseWordsInput();
          if (!words) {
            showLoading(false);
            return;
          }
          const puzzleTitle = document.getElementById('puzzleTitle').value || "Crossword Puzzle";
          document.getElementById('previewTitle').textContent = puzzleTitle;
          document.getElementById('answerKeyTitle').textContent = puzzleTitle;

          try {
            generatedPuzzle = createCrosswordGrid(words);
            renderCrossword(generatedPuzzle, false); // Worksheet
            renderCrossword(generatedPuzzle, true);  // Answer Key
            showPreviewTab('worksheet');
          } catch (err) {
            console.error(err);
            showNotification("Error generating crossword. Try different terms.");
          }
        } catch (err) {
          console.error(err);
          showNotification("Error processing input. Check format.");
        } finally {
          showLoading(false);
        }
      }, 100);
    }

    // IMPROVED CROSSWORD ALGORITHM
    function createCrosswordGrid(words) {
      // Sort words by length descending
      words.sort((a, b) => b.word.length - a.word.length);
      
      // IMPROVEMENT 1: Try multiple layouts and score them
      const attempts = 8; // Generate 8 different layouts
      let bestLayout = null;
      let bestScore = -Infinity;
      
      for (let attempt = 0; attempt < attempts; attempt++) {
        try {
          const layout = generateLayout(words, attempt);
          if (!layout) continue; // Skip if the layout couldn't be generated
          
          const score = scoreLayout(layout);
          if (score > bestScore) {
            bestScore = score;
            bestLayout = layout;
          }
        } catch (e) {
          console.log("Layout attempt failed:", e);
          // Continue to next attempt
        }
      }
      
      // If we found a good layout, use it
      if (bestLayout && bestLayout.placedWords.length >= Math.min(words.length * 0.8, words.length)) {
        return bestLayout;
      }
      
      // Fallback to original algorithm if no good layout was found
      return generateOriginalLayout(words);
    }
    
    // IMPROVEMENT 3: Score a layout based on multiple factors
    function scoreLayout(layout) {
      // Count across and down words
      let acrossCount = 0;
      let downCount = 0;
      layout.placedWords.forEach(word => {
        if (word.horizontal) acrossCount++;
        else downCount++;
      });
      
      // Calculate grid dimensions
      const height = layout.grid.length;
      const width = layout.grid[0].length;
      
      // Calculate aspect ratio and how "square" the grid is
      const aspectRatio = width / height;
      const squareness = Math.min(aspectRatio, 1/aspectRatio); // 1.0 is perfectly square
      
      // Calculate balance between across and down words
      const directionBalance = Math.min(acrossCount, downCount) / Math.max(acrossCount, downCount);
      
      // Calculate percentage of words placed
      const wordPlacementRatio = layout.placedWords.length / layout.totalWords;
      
      // Calculate intersections density (intersections per word)
      let intersections = 0;
      for (let i = 0; i < layout.placedWords.length; i++) {
        for (let j = i + 1; j < layout.placedWords.length; j++) {
          if (wordsIntersect(layout.placedWords[i], layout.placedWords[j])) {
            intersections++;
          }
        }
      }
      const intersectionDensity = intersections / Math.max(1, layout.placedWords.length);
      
      // Calculate overall score
      return (wordPlacementRatio * 40) + // Weight of word placement
             (squareness * 30) +          // Weight of grid shape
             (directionBalance * 20) +    // Weight of direction balance
             (intersectionDensity * 10);  // Weight of intersections
    }
    
    // Check if two words intersect
    function wordsIntersect(word1, word2) {
      // Words with same orientation can't intersect
      if (word1.horizontal === word2.horizontal) return false;
      
      const horizontal = word1.horizontal ? word1 : word2;
      const vertical = word1.horizontal ? word2 : word1;
      
      // Check if the horizontal word crosses the vertical word
      return horizontal.startX <= vertical.startX && 
             horizontal.startX + horizontal.word.length > vertical.startX &&
             vertical.startY <= horizontal.startY &&
             vertical.startY + vertical.word.length > horizontal.startY;
    }
    
    // Generate a layout with the given words
    function generateLayout(words, attemptNumber) {
      const gridSize = calculateGridSize(words);
      const grid = createEmptyGrid(gridSize);
      const placedWords = [];
      
      // IMPROVEMENT 2 & 4: Track direction balance and vary first word orientation
      let acrossCount = 0;
      let downCount = 0;
      
      // Alternate between horizontal and vertical for the first word
      const firstWordHorizontal = attemptNumber % 2 === 0;
      
      // Place first word
      const firstWord = words[0];
      const startX = Math.floor((gridSize - firstWord.word.length) / 2);
      const startY = Math.floor(gridSize / 2);
      
      placeWordOnGrid(grid, firstWord.word, startX, startY, firstWordHorizontal);
      placedWords.push({
        word: firstWord.word,
        clue: firstWord.clue,
        startX: startX,
        startY: startY,
        horizontal: firstWordHorizontal
      });
      
      if (firstWordHorizontal) acrossCount++;
      else downCount++;
      
      // Add randomness by shuffling the word order for each attempt
      const remainingWords = [...words.slice(1)];
      if (attemptNumber > 0) {
        // Use a different shuffle pattern for each attempt
        for (let i = 0; i < attemptNumber; i++) {
          remainingWords.sort(() => Math.random() - 0.5);
        }
      }
      
      // Try to place each remaining word
      for (let i = 0; i < remainingWords.length; i++) {
        const currentWord = remainingWords[i];
        let placementFound = false;
        
        // IMPROVEMENT 2: Balance across and down words
        const preferHorizontal = acrossCount <= downCount;
        
        // Get all possible placements
        const possiblePlacements = findPossiblePlacements(grid, currentWord, placedWords, preferHorizontal);
        
        if (possiblePlacements.length > 0) {
          // IMPROVEMENT 5: Sort placements by intersection quality
          possiblePlacements.sort((a, b) => b.score - a.score);
          
          // Use the best placement
          const bestPlacement = possiblePlacements[0];
          placeWordOnGrid(grid, currentWord.word, bestPlacement.x, bestPlacement.y, bestPlacement.horizontal);
          placedWords.push({
            word: currentWord.word,
            clue: currentWord.clue,
            startX: bestPlacement.x,
            startY: bestPlacement.y,
            horizontal: bestPlacement.horizontal
          });
          
          if (bestPlacement.horizontal) acrossCount++;
          else downCount++;
          
          placementFound = true;
        }
        
        // If no placement found, move to the next word
        if (!placementFound) {
          continue;
        }
      }
      
      // Trim the grid to remove empty space
      const trimmed = trimGrid(grid);
      
      // Adjust word positions based on the trimmed grid
      const adjustX = trimmed.trimFromLeft;
      const adjustY = trimmed.trimFromTop;
      
      for (let i = 0; i < placedWords.length; i++) {
        placedWords[i].startX -= adjustX;
        placedWords[i].startY -= adjustY;
      }
      
      // Number the grid
      numberGrid(trimmed.grid, placedWords);
      
      // Separate clues into across and down
      const acrossClues = [];
      const downClues = [];
      
      for (let w of placedWords) {
        if (w.horizontal) {
          acrossClues.push({ number: w.number, clue: w.clue, word: w.word });
        } else {
          downClues.push({ number: w.number, clue: w.clue, word: w.word });
        }
      }
      
      acrossClues.sort((a, b) => a.number - b.number);
      downClues.sort((a, b) => a.number - b.number);
      
      return {
        grid: trimmed.grid,
        placedWords: placedWords,
        acrossClues,
        downClues,
        totalWords: words.length
      };
    }
    
// Find all possible placements for a word
    function findPossiblePlacements(grid, currentWord, placedWords, preferHorizontal) {
      const possiblePlacements = [];
      
      // Try both orientations, but prioritize the preferred one
      const orientations = preferHorizontal ? 
            [{ horizontal: true }, { horizontal: false }] : 
            [{ horizontal: false }, { horizontal: true }];
      
      for (const orientation of orientations) {
        for (const placedWord of placedWords) {
          // Skip words with the same orientation if we're trying to balance
          if (placedWord.horizontal === orientation.horizontal && 
              (orientation.horizontal ? placedWords.filter(w => w.horizontal).length > placedWords.filter(w => !w.horizontal).length : 
                                        placedWords.filter(w => !w.horizontal).length > placedWords.filter(w => w.horizontal).length)) {
            continue;
          }
          
          for (let i = 0; i < currentWord.word.length; i++) {
            for (let j = 0; j < placedWord.word.length; j++) {
              if (currentWord.word[i] === placedWord.word[j]) {
                let x, y;
                
                if (orientation.horizontal) {
                  x = placedWord.startX + (placedWord.horizontal ? j : 0) - i;
                  y = placedWord.startY + (placedWord.horizontal ? 0 : j);
                } else {
                  x = placedWord.startX + (placedWord.horizontal ? j : 0);
                  y = placedWord.startY + (placedWord.horizontal ? 0 : j) - i;
                }
                
                if (canPlaceWord(grid, currentWord.word, x, y, orientation.horizontal)) {
                  // Calculate a score for this placement
                  const potentialScore = calculatePlacementScore(grid, currentWord.word, x, y, orientation.horizontal, placedWords);
                  
                  possiblePlacements.push({
                    x,
                    y,
                    horizontal: orientation.horizontal,
                    score: potentialScore,
                    intersectionPoint: { wordIndex: i, placedWordIndex: j }
                  });
                }
              }
            }
          }
        }
      }
      
      return possiblePlacements;
    }
    
    // Calculate a score for a potential word placement
    function calculatePlacementScore(grid, word, startX, startY, horizontal, placedWords) {
      let score = 0;
      
      // Score for number of intersections
      for (let i = 0; i < word.length; i++) {
        const x = horizontal ? startX + i : startX;
        const y = horizontal ? startY : startY + i;
        
        // If this position already has a letter, it's an intersection
        if (grid[y] && grid[y][x] === word[i]) {
          score += 5; // Bonus for each intersection
        }
      }
      
      // Penalty for expanding the grid too much
      const currentMaxX = Math.max(...placedWords.map(w => w.horizontal ? w.startX + w.word.length - 1 : w.startX));
      const currentMaxY = Math.max(...placedWords.map(w => w.horizontal ? w.startY : w.startY + w.word.length - 1));
      const currentMinX = Math.min(...placedWords.map(w => w.startX));
      const currentMinY = Math.min(...placedWords.map(w => w.startY));
      
      const newMaxX = horizontal ? startX + word.length - 1 : startX;
      const newMaxY = horizontal ? startY : startY + word.length - 1;
      
      // Calculate how much this placement expands the grid
      const expansion = Math.max(0, newMaxX - currentMaxX) + Math.max(0, newMaxY - currentMaxY) + 
                        Math.max(0, currentMinX - startX) + Math.max(0, currentMinY - startY);
      
      score -= expansion; // Penalty for expanding the grid
      
      // Bonus for placements that help balance the grid shape
      const currentWidth = currentMaxX - currentMinX + 1;
      const currentHeight = currentMaxY - currentMinY + 1;
      const currentRatio = currentWidth / currentHeight;
      
      const newWidth = Math.max(currentMaxX, newMaxX) - Math.min(currentMinX, startX) + 1;
      const newHeight = Math.max(currentMaxY, newMaxY) - Math.min(currentMinY, startY) + 1;
      const newRatio = newWidth / newHeight;
      
      // If the new ratio is closer to 1 (more square), give a bonus
      if (Math.abs(newRatio - 1) < Math.abs(currentRatio - 1)) {
        score += 3;
      }
      
      return score;
    }
    
    // Original layout generation for fallback
    function generateOriginalLayout(words) {
      const gridSize = calculateGridSize(words);
      const grid = createEmptyGrid(gridSize);
      const placedWords = [];

      // Place first word in the middle horizontally
      const firstWord = words[0];
      const startX = Math.floor((gridSize - firstWord.word.length) / 2);
      const startY = Math.floor(gridSize / 2);
      placeWordOnGrid(grid, firstWord.word, startX, startY, true);
      placedWords.push({
        word: firstWord.word,
        clue: firstWord.clue,
        startX: startX,
        startY: startY,
        horizontal: true
      });

      // Attempt to place remaining
      for (let i = 1; i < words.length; i++) {
        const currentWord = words[i];
        let placed = false;

        for (let j = 0; j < placedWords.length && !placed; j++) {
          const placedWord = placedWords[j];
          // horizontal intersection
          if (!placedWord.horizontal) {
            for (let charIndex = 0; charIndex < currentWord.word.length && !placed; charIndex++) {
              for (let pc = 0; pc < placedWord.word.length && !placed; pc++) {
                if (currentWord.word[charIndex] === placedWord.word[pc]) {
                  const newX = placedWord.startX - charIndex;
                  const newY = placedWord.startY + pc;
                  if (canPlaceWord(grid, currentWord.word, newX, newY, true)) {
                    placeWordOnGrid(grid, currentWord.word, newX, newY, true);
                    placedWords.push({
                      word: currentWord.word,
                      clue: currentWord.clue,
                      startX: newX,
                      startY: newY,
                      horizontal: true
                    });
                    placed = true;
                  }
                }
              }
            }
          }
          // vertical intersection
          if (placedWord.horizontal && !placed) {
            for (let charIndex = 0; charIndex < currentWord.word.length && !placed; charIndex++) {
              for (let pc = 0; pc < placedWord.word.length && !placed; pc++) {
                if (currentWord.word[charIndex] === placedWord.word[pc]) {
                  const newX = placedWord.startX + pc;
                  const newY = placedWord.startY - charIndex;
                  if (canPlaceWord(grid, currentWord.word, newX, newY, false)) {
                    placeWordOnGrid(grid, currentWord.word, newX, newY, false);
                    placedWords.push({
                      word: currentWord.word,
                      clue: currentWord.clue,
                      startX: newX,
                      startY: newY,
                      horizontal: false
                    });
                    placed = true;
                  }
                }
              }
            }
          }
        }
      }
      
      // Trim the grid
      const trimmed = trimGrid(grid);
      
      // Adjust word positions based on the trimmed grid
      const adjustX = trimmed.trimFromLeft;
      const adjustY = trimmed.trimFromTop;
      
      for (let i = 0; i < placedWords.length; i++) {
        placedWords[i].startX -= adjustX;
        placedWords[i].startY -= adjustY;
      }
      
      // Number the grid
      numberGrid(trimmed.grid, placedWords);
      
      // Prepare clues
      const acrossClues = [];
      const downClues = [];
      
      for (let w of placedWords) {
        if (w.horizontal) {
          acrossClues.push({ number: w.number, clue: w.clue, word: w.word });
        } else {
          downClues.push({ number: w.number, clue: w.clue, word: w.word });
        }
      }
      
      acrossClues.sort((a, b) => a.number - b.number);
      downClues.sort((a, b) => a.number - b.number);
      
      return {
        grid: trimmed.grid,
        placedWords: placedWords,
        acrossClues,
        downClues,
        totalWords: words.length
      };
    }

    function calculateGridSize(words) {
      let maxLength = 0;
      for (let w of words) {
        maxLength = Math.max(maxLength, w.word.length);
      }
      // some padding
      return Math.max(20, maxLength + 10);
    }

    function createEmptyGrid(size) {
      const g = [];
      for (let y = 0; y < size; y++) {
        g[y] = [];
        for (let x = 0; x < size; x++) {
          g[y][x] = null;
        }
      }
      return g;
    }

    function canPlaceWord(grid, word, startX, startY, horizontal) {
      const gridSize = grid.length;
      if (horizontal) {
        if (startX < 0 || startX + word.length > gridSize || startY < 0 || startY >= gridSize) {
          return false;
        }
      } else {
        if (startX < 0 || startX >= gridSize || startY < 0 || startY + word.length > gridSize) {
          return false;
        }
      }
      let hasIntersection = false;
      for (let i = 0; i < word.length; i++) {
        const x = horizontal ? startX + i : startX;
        const y = horizontal ? startY : startY + i;
        if (grid[y][x] !== null && grid[y][x] !== word[i]) {
          return false;
        }
        if (grid[y][x] === word[i]) {
          hasIntersection = true;
        } else {
          // Check adjacent cells (no adjacent letters allowed unless at intersection)
          if (horizontal) {
            // Check above
            if (y > 0 && grid[y-1][x] !== null) {
              return false;
            }
            // Check below
            if (y < gridSize - 1 && grid[y+1][x] !== null) {
              return false;
            }
            // Check before word start
            if (i === 0 && x > 0 && grid[y][x-1] !== null) {
              return false;
            }
            // Check after word end
            if (i === word.length - 1 && x < gridSize - 1 && grid[y][x+1] !== null) {
              return false;
            }
          } else {
            // Check left
            if (x > 0 && grid[y][x-1] !== null) {
              return false;
            }
            // Check right
            if (x < gridSize - 1 && grid[y][x+1] !== null) {
              return false;
            }
            // Check before word start
            if (i === 0 && y > 0 && grid[y-1][x] !== null) {
              return false;
            }
            // Check after word end
            if (i === word.length - 1 && y < gridSize - 1 && grid[y+1][x] !== null) {
              return false;
            }
          }
        }
      }
      // Word must have at least one intersection with existing words
      return hasIntersection || (startX === Math.floor((gridSize - word.length) / 2)
             && startY === Math.floor(gridSize / 2));
    }

    function placeWordOnGrid(grid, word, startX, startY, horizontal) {
      for (let i = 0; i < word.length; i++) {
        if (horizontal) {
          grid[startY][startX + i] = word[i];
        } else {
          grid[startY + i][startX] = word[i];
        }
      }
    }

    function trimGrid(grid) {
      const size = grid.length;
      let minX = size, maxX = 0, minY = size, maxY = 0;
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (grid[y][x] !== null) {
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
          }
        }
      }
      minX = Math.max(0, minX - 1);
      minY = Math.max(0, minY - 1);
      maxX = Math.min(size - 1, maxX + 1);
      maxY = Math.min(size - 1, maxY + 1);
      const newWidth = maxX - minX + 1;
      const newHeight = maxY - minY + 1;
      const trimmedGrid = [];
      for (let y = 0; y < newHeight; y++) {
        trimmedGrid[y] = [];
        for (let x = 0; x < newWidth; x++) {
          trimmedGrid[y][x] = grid[y + minY][x + minX];
        }
      }
      return {
        grid: trimmedGrid,
        trimFromLeft: minX,
        trimFromTop: minY
      };
    }

    function numberGrid(grid, placedWords) {
      const height = grid.length;
      const width = grid[0].length;
      let currentNumber = 1;
      for (let pw of placedWords) {
        delete pw.number;
      }
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          if (grid[y][x] !== null) {
            let numberH = false;
            let numberV = false;
            if ((x === 0 || grid[y][x-1] === null)
                && (x < width - 1 && grid[y][x+1] !== null)) {
              numberH = true;
            }
            if ((y === 0 || grid[y-1][x] === null)
                && (y < height - 1 && grid[y+1][x] !== null)) {
              numberV = true;
            }
            if (numberH || numberV) {
              // Assign the number to matching words
              if (numberH) {
                for (let pw of placedWords) {
                  if (pw.horizontal && pw.startX === x && pw.startY === y) {
                    pw.number = currentNumber;
                  }
                }
              }
              if (numberV) {
                for (let pw of placedWords) {
                  if (!pw.horizontal && pw.startX === x && pw.startY === y) {
                    pw.number = currentNumber;
                  }
                }
              }
              currentNumber++;
            }
          }
        }
      }
      // If any words have no number, assign one
      for (let pw of placedWords) {
        if (pw.number === undefined) {
          pw.number = currentNumber++;
        }
      }
    }

    function renderCrossword(puzzle, showAnswers) {
      const grid = puzzle.grid;
      const height = grid.length;
      const width = grid[0].length;
      
      // Cell size
      const maxDim = Math.max(width, height);
      let cellSize = '25px';
      if (maxDim > 15) { cellSize = '22px'; }
      else if (maxDim > 12) { cellSize = '24px'; }

      let html = `<div class="crossword-grid-container">
                    <table class="crossword-grid" style="--cell-size: ${cellSize};">`;
      for (let y = 0; y < height; y++) {
        html += '<tr>';
        for (let x = 0; x < width; x++) {
          if (grid[y][x] === null) {
            html += '<td></td>';
          } else {
            let cellNumber = '';
            if (isStartOfWord(grid, x, y)) {
              const n = getWordNumber(puzzle.placedWords, x, y);
              if (n) {
                cellNumber = `<span class="cell-number">${n}</span>`;
              }
            }
            const cellContent = showAnswers ? grid[y][x] : '';
            html += `<td class="crossword-cell">${cellNumber}${cellContent}</td>`;
          }
        }
        html += '</tr>';
      }
      html += '</table></div>';
      
      // Clues
      html += '<div class="clues-container">';
      if (puzzle.acrossClues.length > 0) {
        html += '<div class="across-clues">';
        html += '<div class="worksheet-heading">Across:</div>';
        html += '<ol class="clue-list">';
        for (let clue of puzzle.acrossClues) {
          html += `<li class="clue-item"><strong>${clue.number}.</strong> ${clue.clue}</li>`;
        }
        html += '</ol></div>';
      }
      if (puzzle.downClues.length > 0) {
        html += '<div class="down-clues">';
        html += '<div class="worksheet-heading">Down:</div>';
        html += '<ol class="clue-list">';
        for (let clue of puzzle.downClues) {
          html += `<li class="clue-item"><strong>${clue.number}.</strong> ${clue.clue}</li>`;
        }
        html += '</ol></div>';
      }
      html += '</div>';

      // Update both the preview and PDF export containers
      if (showAnswers) {
        document.getElementById('answerKeyContainer').innerHTML = html;
        
        // For PDF export - full unscaled version
        document.getElementById('pdfAnswerKeyContainer').innerHTML = 
          `<div class="preview-content">
            <div class="pdf-export-wrapper">
              <h3 class="preview-title">${document.getElementById('puzzleTitle').value || "Crossword Puzzle"}</h3>
              ${html}
            </div>
          </div>`;
      } else {
        document.getElementById('crosswordContainer').innerHTML = html;
        
        // For PDF export - full unscaled version
        document.getElementById('pdfWorksheetContainer').innerHTML = 
          `<div class="preview-content">
            <div class="pdf-export-wrapper">
              <h3 class="preview-title">${document.getElementById('puzzleTitle').value || "Crossword Puzzle"}</h3>
              ${html}
            </div>
          </div>`;
      }
      
      updatePreviewScale(); // <-- scale preview each time
    }

    function isStartOfWord(grid, x, y) {
      if (grid[y][x] === null) return false;
      const height = grid.length;
      const width = grid[0].length;
      const horizStart = ((x === 0 || grid[y][x-1] === null)
                          && (x < width - 1 && grid[y][x+1] !== null));
      const vertStart = ((y === 0 || grid[y-1][x] === null)
                          && (y < height - 1 && grid[y+1][x] !== null));
      return horizStart || vertStart;
    }

    function getWordNumber(placedWords, x, y) {
      for (let pw of placedWords) {
        if (pw.startX === x && pw.startY === y) {
          return pw.number;
        }
      }
      return null;
    }

    // PDF export
    function printPuzzle() {
      if (!generatedPuzzle) {
        showNotification("Generate a puzzle first");
        return;
      }
      
      const puzzleTitle = (document.getElementById('puzzleTitle').value || "Crossword_Puzzle")
                          .replace(/\s+/g, '_');
      const filename = puzzleTitle + '.pdf';
      
      // Use the unscaled version for PDF export
      const content = document.getElementById('pdfWorksheetContainer');
      content.classList.add('active'); // Make it visible for html2pdf
      
      // Ensure all content is visible
      const cluesContainer = content.querySelector('.clues-container');
      if (cluesContainer) {
        cluesContainer.style.display = 'block';
        cluesContainer.style.visibility = 'visible';
        cluesContainer.style.height = 'auto';
      }
      
      const options = {
        margin: [10, 10, 10, 10],
        filename: filename,
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: {
          scale: 2,
          useCORS: true,
          scrollY: 0,
          windowHeight: 2000, // Ensure there's enough height to capture everything
          onclone: function(doc) {
            // Force visibility of clues in PDF
            const cluesContainer = doc.querySelector('.pdf-export-container .clues-container');
            if (cluesContainer) {
              cluesContainer.style.display = 'block';
              cluesContainer.style.visibility = 'visible';
              cluesContainer.style.position = 'static';
              cluesContainer.style.overflow = 'visible';
              cluesContainer.style.height = 'auto';
            }
          }
        },
        jsPDF: {
          unit: 'mm',
          format: 'a4',
          orientation: 'portrait',
          compress: true
        },
        pagebreak: { mode: ['avoid', 'css', 'legacy'], avoid: '.pdf-export-wrapper' }
      };
      
      showLoading(true);
      
      // Add a slight delay to ensure DOM is fully rendered
      setTimeout(() => {
        html2pdf()
          .set(options)
          .from(content)
          .save()
          .then(() => {
            content.classList.remove('active');
            showLoading(false);
            showNotification("Worksheet downloaded successfully");
          })
          .catch(err => {
            content.classList.remove('active');
            showLoading(false);
            console.error("PDF generation error:", err);
            showNotification("Error downloading PDF. Try again.");
          });
      }, 100);
    }

    function printAnswerKey() {
      if (!generatedPuzzle) {
        showNotification("Generate a puzzle first");
        return;
      }
      
      const puzzleTitle = (document.getElementById('puzzleTitle').value || "Crossword_Puzzle")
                          .replace(/\s+/g, '_');
      const filename = puzzleTitle + '_Answer_Key.pdf';
      
      // Use the unscaled version for PDF export
      const content = document.getElementById('pdfAnswerKeyContainer');
      content.classList.add('active'); // Make it visible for html2pdf
      
      // Ensure all content is visible
      const cluesContainer = content.querySelector('.clues-container');
      if (cluesContainer) {
        cluesContainer.style.display = 'block';
        cluesContainer.style.visibility = 'visible';
        cluesContainer.style.height = 'auto';
      }
      
      const options = {
        margin: [10, 10, 10, 10],
        filename: filename,
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: {
          scale: 2,
          useCORS: true,
          scrollY: 0,
          windowHeight: 2000, // Ensure there's enough height to capture everything
          onclone: function(doc) {
            // Force visibility of clues in PDF
            const cluesContainer = doc.querySelector('.pdf-export-container .clues-container');
            if (cluesContainer) {
              cluesContainer.style.display = 'block';
              cluesContainer.style.visibility = 'visible';
              cluesContainer.style.position = 'static';
              cluesContainer.style.overflow = 'visible';
              cluesContainer.style.height = 'auto';
            }
          }
        },
        jsPDF: {
          unit: 'mm',
          format: 'a4',
          orientation: 'portrait',
          compress: true
        },
        pagebreak: { mode: ['avoid', 'css', 'legacy'], avoid: '.pdf-export-wrapper' }
      };
      
      showLoading(true);
      
      // Add a slight delay to ensure DOM is fully rendered
      setTimeout(() => {
        html2pdf()
          .set(options)
          .from(content)
          .save()
          .then(() => {
            content.classList.remove('active');
            showLoading(false);
            showNotification("Answer key downloaded successfully");
          })
          .catch(err => {
            content.classList.remove('active');
            showLoading(false);
            console.error("PDF generation error:", err);
            showNotification("Error downloading PDF. Try again.");
          });
      }, 100);
    }
  </script>
</body>
</html>
